
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000116  00800100  00000b60  00000bf4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b60  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000f  00800216  00800216  00000d0a  2**0
                  ALLOC
  3 .stab         00000378  00000000  00000000  00000d0c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000071  00000000  00000000  00001084  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000074  00000000  00000000  000010f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001d7  00000000  00000000  00001169  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000922  00000000  00000000  00001340  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004dc  00000000  00000000  00001c62  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000c13  00000000  00000000  0000213e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000e0  00000000  00000000  00002d54  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000033f  00000000  00000000  00002e34  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000000fd  00000000  00000000  00003173  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 0000000c  00000000  00000000  00003270  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 38 00 	jmp	0x70	; 0x70 <__ctors_end>
   4:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
   8:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
   c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  10:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  14:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  18:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  1c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  20:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  24:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  28:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  2c:	0c 94 cb 04 	jmp	0x996	; 0x996 <__vector_11>
  30:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  34:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  38:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  3c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  40:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  44:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  48:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  4c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  50:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  54:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  58:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  5c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  60:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  64:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  68:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  6c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>

00000070 <__ctors_end>:
  70:	11 24       	eor	r1, r1
  72:	1f be       	out	0x3f, r1	; 63
  74:	cf ef       	ldi	r28, 0xFF	; 255
  76:	d0 e1       	ldi	r29, 0x10	; 16
  78:	de bf       	out	0x3e, r29	; 62
  7a:	cd bf       	out	0x3d, r28	; 61

0000007c <__do_copy_data>:
  7c:	12 e0       	ldi	r17, 0x02	; 2
  7e:	a0 e0       	ldi	r26, 0x00	; 0
  80:	b1 e0       	ldi	r27, 0x01	; 1
  82:	e0 e6       	ldi	r30, 0x60	; 96
  84:	fb e0       	ldi	r31, 0x0B	; 11
  86:	02 c0       	rjmp	.+4      	; 0x8c <.do_copy_data_start>

00000088 <.do_copy_data_loop>:
  88:	05 90       	lpm	r0, Z+
  8a:	0d 92       	st	X+, r0

0000008c <.do_copy_data_start>:
  8c:	a6 31       	cpi	r26, 0x16	; 22
  8e:	b1 07       	cpc	r27, r17
  90:	d9 f7       	brne	.-10     	; 0x88 <.do_copy_data_loop>

00000092 <__do_clear_bss>:
  92:	12 e0       	ldi	r17, 0x02	; 2
  94:	a6 e1       	ldi	r26, 0x16	; 22
  96:	b2 e0       	ldi	r27, 0x02	; 2
  98:	01 c0       	rjmp	.+2      	; 0x9c <.do_clear_bss_start>

0000009a <.do_clear_bss_loop>:
  9a:	1d 92       	st	X+, r1

0000009c <.do_clear_bss_start>:
  9c:	a5 32       	cpi	r26, 0x25	; 37
  9e:	b1 07       	cpc	r27, r17
  a0:	e1 f7       	brne	.-8      	; 0x9a <.do_clear_bss_loop>
  a2:	0e 94 27 01 	call	0x24e	; 0x24e <main>
  a6:	0c 94 af 05 	jmp	0xb5e	; 0xb5e <_exit>

000000aa <__bad_interrupt>:
  aa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ae <drawMenue>:
/*
*	Zeichnet das Komplette Menü neu
*/
void drawMenue(menue *m)		//Zeichnet das Display neu
{
  ae:	ef 92       	push	r14
  b0:	ff 92       	push	r15
  b2:	0f 93       	push	r16
  b4:	1f 93       	push	r17
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	8c 01       	movw	r16, r24
	int i;
	lcd_gotoxy(0,2);
  bc:	62 e0       	ldi	r22, 0x02	; 2
  be:	80 e0       	ldi	r24, 0x00	; 0
  c0:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
	lcd_command(LCD_CLEAR);	
  c4:	81 e0       	ldi	r24, 0x01	; 1
  c6:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
	lcd_gotoxy(0,0);
  ca:	60 e0       	ldi	r22, 0x00	; 0
  cc:	80 e0       	ldi	r24, 0x00	; 0
  ce:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
	lcd_command(LCD_CLEAR);	
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
  d8:	c0 e0       	ldi	r28, 0x00	; 0
  da:	d0 e0       	ldi	r29, 0x00	; 0
	
	for(i=0;i<27;i++)
	{		
		lcd_putc(0xA5);
  dc:	85 ea       	ldi	r24, 0xA5	; 165
  de:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
  e2:	21 96       	adiw	r28, 0x01	; 1
  e4:	cb 31       	cpi	r28, 0x1B	; 27
  e6:	d1 05       	cpc	r29, r1
  e8:	c9 f7       	brne	.-14     	; 0xdc <drawMenue+0x2e>
	}
	lcd_gotoxy(13-(m->titelLaenge/2),0);
  ea:	f8 01       	movw	r30, r16
  ec:	94 8d       	ldd	r25, Z+28	; 0x1c
  ee:	96 95       	lsr	r25
  f0:	60 e0       	ldi	r22, 0x00	; 0
  f2:	8d e0       	ldi	r24, 0x0D	; 13
  f4:	89 1b       	sub	r24, r25
  f6:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
	lcd_puts((char *)m->titel);
  fa:	c8 01       	movw	r24, r16
  fc:	0e 94 1e 04 	call	0x83c	; 0x83c <lcd_puts>
 100:	c1 e0       	ldi	r28, 0x01	; 1
 102:	d0 e0       	ldi	r29, 0x00	; 0
	
	for(i=1; i<4;i++)
	{
		if(i+m->offset > m->anzEintr)
 104:	3c e9       	ldi	r19, 0x9C	; 156
 106:	e3 2e       	mov	r14, r19
 108:	f1 2c       	mov	r15, r1
 10a:	e0 0e       	add	r14, r16
 10c:	f1 1e       	adc	r15, r17
 10e:	f7 01       	movw	r30, r14
 110:	80 81       	ld	r24, Z
 112:	9e 01       	movw	r18, r28
 114:	28 0f       	add	r18, r24
 116:	31 1d       	adc	r19, r1
 118:	05 56       	subi	r16, 0x65	; 101
 11a:	1f 4f       	sbci	r17, 0xFF	; 255
 11c:	f8 01       	movw	r30, r16
 11e:	80 81       	ld	r24, Z
 120:	0b 59       	subi	r16, 0x9B	; 155
 122:	10 40       	sbci	r17, 0x00	; 0
 124:	99 27       	eor	r25, r25
 126:	82 17       	cp	r24, r18
 128:	93 07       	cpc	r25, r19
 12a:	f4 f0       	brlt	.+60     	; 0x168 <drawMenue+0xba>
			break;
		lcd_gotoxy(5,i);
 12c:	6c 2f       	mov	r22, r28
 12e:	85 e0       	ldi	r24, 0x05	; 5
 130:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
		lcd_putc(0x7C);
 134:	8c e7       	ldi	r24, 0x7C	; 124
 136:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
		lcd_puts(m->eintrag[(i+m->offset)-1]);
 13a:	f7 01       	movw	r30, r14
 13c:	80 81       	ld	r24, Z
 13e:	9e 01       	movw	r18, r28
 140:	28 0f       	add	r18, r24
 142:	31 1d       	adc	r19, r1
 144:	c9 01       	movw	r24, r18
 146:	24 e0       	ldi	r18, 0x04	; 4
 148:	88 0f       	add	r24, r24
 14a:	99 1f       	adc	r25, r25
 14c:	2a 95       	dec	r18
 14e:	e1 f7       	brne	.-8      	; 0x148 <drawMenue+0x9a>
 150:	80 0f       	add	r24, r16
 152:	91 1f       	adc	r25, r17
 154:	0d 96       	adiw	r24, 0x0d	; 13
 156:	0e 94 1e 04 	call	0x83c	; 0x83c <lcd_puts>
		lcd_putc(0x7C);
 15a:	8c e7       	ldi	r24, 0x7C	; 124
 15c:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 160:	21 96       	adiw	r28, 0x01	; 1
 162:	c4 30       	cpi	r28, 0x04	; 4
 164:	d1 05       	cpc	r29, r1
 166:	71 f6       	brne	.-100    	; 0x104 <drawMenue+0x56>
 168:	df 91       	pop	r29
 16a:	cf 91       	pop	r28
 16c:	1f 91       	pop	r17
 16e:	0f 91       	pop	r16
 170:	ff 90       	pop	r15
 172:	ef 90       	pop	r14
 174:	08 95       	ret

00000176 <reDrawMenue>:
	}
}


/*
*	Zechnet die Auswahlpfeile und rollt bei Bedarf das Menü
*/
void reDrawMenue(menue *m)
{
 176:	ff 92       	push	r15
 178:	0f 93       	push	r16
 17a:	1f 93       	push	r17
 17c:	cf 93       	push	r28
 17e:	df 93       	push	r29
 180:	ec 01       	movw	r28, r24
	int i;
	
	// Rollt das menue
	if((arrow - m->offset) > 3)
 182:	30 91 16 02 	lds	r19, 0x0216
 186:	83 2f       	mov	r24, r19
 188:	99 27       	eor	r25, r25
 18a:	87 fd       	sbrc	r24, 7
 18c:	90 95       	com	r25
 18e:	8e 01       	movw	r16, r28
 190:	04 56       	subi	r16, 0x64	; 100
 192:	1f 4f       	sbci	r17, 0xFF	; 255
 194:	f8 01       	movw	r30, r16
 196:	20 81       	ld	r18, Z
 198:	82 1b       	sub	r24, r18
 19a:	91 09       	sbc	r25, r1
 19c:	04 97       	sbiw	r24, 0x04	; 4
 19e:	2c f0       	brlt	.+10     	; 0x1aa <reDrawMenue+0x34>
	{
		m->offset=arrow - 3;
 1a0:	33 50       	subi	r19, 0x03	; 3
 1a2:	30 83       	st	Z, r19
		drawMenue(m);
 1a4:	ce 01       	movw	r24, r28
 1a6:	0e 94 57 00 	call	0xae	; 0xae <drawMenue>
	}
	if((arrow - m->offset) <= 0)
 1aa:	30 91 16 02 	lds	r19, 0x0216
 1ae:	83 2f       	mov	r24, r19
 1b0:	99 27       	eor	r25, r25
 1b2:	87 fd       	sbrc	r24, 7
 1b4:	90 95       	com	r25
 1b6:	f8 01       	movw	r30, r16
 1b8:	20 81       	ld	r18, Z
 1ba:	82 1b       	sub	r24, r18
 1bc:	91 09       	sbc	r25, r1
 1be:	18 16       	cp	r1, r24
 1c0:	19 06       	cpc	r1, r25
 1c2:	2c f0       	brlt	.+10     	; 0x1ce <reDrawMenue+0x58>
	{
		m->offset = arrow - 1;
 1c4:	31 50       	subi	r19, 0x01	; 1
 1c6:	30 83       	st	Z, r19
		drawMenue(m);
 1c8:	ce 01       	movw	r24, r28
 1ca:	0e 94 57 00 	call	0xae	; 0xae <drawMenue>
 1ce:	01 e0       	ldi	r16, 0x01	; 1
 1d0:	10 e0       	ldi	r17, 0x00	; 0
 1d2:	f0 2e       	mov	r15, r16
	}
	
		
	// Zeichnet die Pfeile
	for(i=1;i<4;i++)
	{
		lcd_gotoxy(4,i);
 1d4:	60 2f       	mov	r22, r16
 1d6:	84 e0       	ldi	r24, 0x04	; 4
 1d8:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
		if(arrow == i+m->offset)
 1dc:	80 91 16 02 	lds	r24, 0x0216
 1e0:	99 27       	eor	r25, r25
 1e2:	87 fd       	sbrc	r24, 7
 1e4:	90 95       	com	r25
 1e6:	c4 56       	subi	r28, 0x64	; 100
 1e8:	df 4f       	sbci	r29, 0xFF	; 255
 1ea:	28 81       	ld	r18, Y
 1ec:	cc 59       	subi	r28, 0x9C	; 156
 1ee:	d0 40       	sbci	r29, 0x00	; 0
 1f0:	a8 01       	movw	r20, r16
 1f2:	42 0f       	add	r20, r18
 1f4:	51 1d       	adc	r21, r1
 1f6:	84 17       	cp	r24, r20
 1f8:	95 07       	cpc	r25, r21
 1fa:	11 f4       	brne	.+4      	; 0x200 <reDrawMenue+0x8a>
			lcd_putc(0x7E);
 1fc:	8e e7       	ldi	r24, 0x7E	; 126
 1fe:	01 c0       	rjmp	.+2      	; 0x202 <reDrawMenue+0x8c>
		else
			lcd_putc(' ');
 200:	80 e2       	ldi	r24, 0x20	; 32
 202:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
		
		lcd_gotoxy(22,i);
 206:	6f 2d       	mov	r22, r15
 208:	86 e1       	ldi	r24, 0x16	; 22
 20a:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
		if(arrow == i+m->offset)
 20e:	80 91 16 02 	lds	r24, 0x0216
 212:	99 27       	eor	r25, r25
 214:	87 fd       	sbrc	r24, 7
 216:	90 95       	com	r25
 218:	c4 56       	subi	r28, 0x64	; 100
 21a:	df 4f       	sbci	r29, 0xFF	; 255
 21c:	28 81       	ld	r18, Y
 21e:	cc 59       	subi	r28, 0x9C	; 156
 220:	d0 40       	sbci	r29, 0x00	; 0
 222:	f8 01       	movw	r30, r16
 224:	e2 0f       	add	r30, r18
 226:	f1 1d       	adc	r31, r1
 228:	8e 17       	cp	r24, r30
 22a:	9f 07       	cpc	r25, r31
 22c:	11 f4       	brne	.+4      	; 0x232 <reDrawMenue+0xbc>
			lcd_putc(0x7F);
 22e:	8f e7       	ldi	r24, 0x7F	; 127
 230:	01 c0       	rjmp	.+2      	; 0x234 <reDrawMenue+0xbe>
		else
			lcd_putc(' ');
 232:	80 e2       	ldi	r24, 0x20	; 32
 234:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 238:	0f 5f       	subi	r16, 0xFF	; 255
 23a:	1f 4f       	sbci	r17, 0xFF	; 255
 23c:	04 30       	cpi	r16, 0x04	; 4
 23e:	11 05       	cpc	r17, r1
 240:	41 f6       	brne	.-112    	; 0x1d2 <reDrawMenue+0x5c>
 242:	df 91       	pop	r29
 244:	cf 91       	pop	r28
 246:	1f 91       	pop	r17
 248:	0f 91       	pop	r16
 24a:	ff 90       	pop	r15
 24c:	08 95       	ret

0000024e <main>:
 24e:	ef 92       	push	r14
 250:	ff 92       	push	r15
 252:	0f 93       	push	r16
 254:	1f 93       	push	r17
 256:	cf 93       	push	r28
 258:	df 93       	push	r29
 25a:	cd b7       	in	r28, 0x3d	; 61
 25c:	de b7       	in	r29, 0x3e	; 62
 25e:	c7 5d       	subi	r28, 0xD7	; 215
 260:	d1 40       	sbci	r29, 0x01	; 1
 262:	0f b6       	in	r0, 0x3f	; 63
 264:	f8 94       	cli
 266:	de bf       	out	0x3e, r29	; 62
 268:	0f be       	out	0x3f, r0	; 63
 26a:	cd bf       	out	0x3d, r28	; 61
 26c:	81 b1       	in	r24, 0x01	; 1
 26e:	88 7f       	andi	r24, 0xF8	; 248
 270:	81 b9       	out	0x01, r24	; 1
 272:	82 b1       	in	r24, 0x02	; 2
 274:	87 60       	ori	r24, 0x07	; 7
 276:	82 b9       	out	0x02, r24	; 2
 278:	8f ef       	ldi	r24, 0xFF	; 255
 27a:	87 b9       	out	0x07, r24	; 7
 27c:	88 b9       	out	0x08, r24	; 8
 27e:	23 9a       	sbi	0x04, 3	; 4
 280:	2b 98       	cbi	0x05, 3	; 5
 282:	80 e0       	ldi	r24, 0x00	; 0
 284:	90 e0       	ldi	r25, 0x00	; 0
 286:	00 00       	nop
 288:	01 96       	adiw	r24, 0x01	; 1
 28a:	25 e7       	ldi	r18, 0x75	; 117
 28c:	81 33       	cpi	r24, 0x31	; 49
 28e:	92 07       	cpc	r25, r18
 290:	d1 f7       	brne	.-12     	; 0x286 <main+0x38>
 292:	85 b1       	in	r24, 0x05	; 5
 294:	98 e0       	ldi	r25, 0x08	; 8
 296:	89 27       	eor	r24, r25
 298:	85 b9       	out	0x05, r24	; 5
 29a:	0e 94 9c 04 	call	0x938	; 0x938 <timer2_init>
 29e:	8c e0       	ldi	r24, 0x0C	; 12
 2a0:	0e 94 81 04 	call	0x902	; 0x902 <lcd_init>
 2a4:	78 94       	sei
 2a6:	8c e0       	ldi	r24, 0x0C	; 12
 2a8:	0e 94 81 04 	call	0x902	; 0x902 <lcd_init>
 2ac:	60 e0       	ldi	r22, 0x00	; 0
 2ae:	80 e0       	ldi	r24, 0x00	; 0
 2b0:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 2b4:	8c e7       	ldi	r24, 0x7C	; 124
 2b6:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2ba:	8e e7       	ldi	r24, 0x7E	; 126
 2bc:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2c0:	61 e0       	ldi	r22, 0x01	; 1
 2c2:	80 e0       	ldi	r24, 0x00	; 0
 2c4:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 2c8:	8c e7       	ldi	r24, 0x7C	; 124
 2ca:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2ce:	8e e7       	ldi	r24, 0x7E	; 126
 2d0:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2d4:	62 e0       	ldi	r22, 0x02	; 2
 2d6:	80 e0       	ldi	r24, 0x00	; 0
 2d8:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 2dc:	8c e7       	ldi	r24, 0x7C	; 124
 2de:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2e2:	8e e7       	ldi	r24, 0x7E	; 126
 2e4:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2e8:	63 e0       	ldi	r22, 0x03	; 3
 2ea:	80 e0       	ldi	r24, 0x00	; 0
 2ec:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 2f0:	8c e7       	ldi	r24, 0x7C	; 124
 2f2:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2f6:	8e e7       	ldi	r24, 0x7E	; 126
 2f8:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 2fc:	61 e0       	ldi	r22, 0x01	; 1
 2fe:	89 e1       	ldi	r24, 0x19	; 25
 300:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 304:	80 e0       	ldi	r24, 0x00	; 0
 306:	91 e0       	ldi	r25, 0x01	; 1
 308:	0e 94 1e 04 	call	0x83c	; 0x83c <lcd_puts>
 30c:	62 e0       	ldi	r22, 0x02	; 2
 30e:	89 e1       	ldi	r24, 0x19	; 25
 310:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 314:	80 e0       	ldi	r24, 0x00	; 0
 316:	91 e0       	ldi	r25, 0x01	; 1
 318:	0e 94 1e 04 	call	0x83c	; 0x83c <lcd_puts>
 31c:	63 e0       	ldi	r22, 0x03	; 3
 31e:	89 e1       	ldi	r24, 0x19	; 25
 320:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 324:	80 e0       	ldi	r24, 0x00	; 0
 326:	91 e0       	ldi	r25, 0x01	; 1
 328:	0e 94 1e 04 	call	0x83c	; 0x83c <lcd_puts>
 32c:	60 e0       	ldi	r22, 0x00	; 0
 32e:	80 e0       	ldi	r24, 0x00	; 0
 330:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 334:	60 e0       	ldi	r22, 0x00	; 0
 336:	80 e0       	ldi	r24, 0x00	; 0
 338:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 33c:	85 ea       	ldi	r24, 0xA5	; 165
 33e:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 342:	85 ea       	ldi	r24, 0xA5	; 165
 344:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 348:	85 ea       	ldi	r24, 0xA5	; 165
 34a:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 34e:	85 ea       	ldi	r24, 0xA5	; 165
 350:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 354:	85 ea       	ldi	r24, 0xA5	; 165
 356:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 35a:	85 ea       	ldi	r24, 0xA5	; 165
 35c:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 360:	85 ea       	ldi	r24, 0xA5	; 165
 362:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 366:	85 ea       	ldi	r24, 0xA5	; 165
 368:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 36c:	83 e0       	ldi	r24, 0x03	; 3
 36e:	91 e0       	ldi	r25, 0x01	; 1
 370:	0e 94 1e 04 	call	0x83c	; 0x83c <lcd_puts>
 374:	85 ea       	ldi	r24, 0xA5	; 165
 376:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 37a:	85 ea       	ldi	r24, 0xA5	; 165
 37c:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 380:	85 ea       	ldi	r24, 0xA5	; 165
 382:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 386:	85 ea       	ldi	r24, 0xA5	; 165
 388:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 38c:	85 ea       	ldi	r24, 0xA5	; 165
 38e:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 392:	85 ea       	ldi	r24, 0xA5	; 165
 394:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 398:	85 ea       	ldi	r24, 0xA5	; 165
 39a:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 39e:	85 ea       	ldi	r24, 0xA5	; 165
 3a0:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 3a4:	61 e0       	ldi	r22, 0x01	; 1
 3a6:	8b e0       	ldi	r24, 0x0B	; 11
 3a8:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 3ac:	8f e0       	ldi	r24, 0x0F	; 15
 3ae:	91 e0       	ldi	r25, 0x01	; 1
 3b0:	0e 94 1e 04 	call	0x83c	; 0x83c <lcd_puts>
 3b4:	63 e0       	ldi	r22, 0x03	; 3
 3b6:	85 e0       	ldi	r24, 0x05	; 5
 3b8:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <lcd_gotoxy>
 3bc:	8f ef       	ldi	r24, 0xFF	; 255
 3be:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 3c2:	8c e7       	ldi	r24, 0x7C	; 124
 3c4:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 3c8:	8e e7       	ldi	r24, 0x7E	; 126
 3ca:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 3ce:	8f e7       	ldi	r24, 0x7F	; 127
 3d0:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 3d4:	8c e7       	ldi	r24, 0x7C	; 124
 3d6:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 3da:	8f ef       	ldi	r24, 0xFF	; 255
 3dc:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 3e0:	81 e0       	ldi	r24, 0x01	; 1
 3e2:	0e 94 6c 05 	call	0xad8	; 0xad8 <get_key_press>
 3e6:	88 23       	and	r24, r24
 3e8:	11 f4       	brne	.+4      	; 0x3ee <main+0x1a0>
 3ea:	00 00       	nop
 3ec:	f9 cf       	rjmp	.-14     	; 0x3e0 <main+0x192>
 3ee:	5b e3       	ldi	r21, 0x3B	; 59
 3f0:	e5 2e       	mov	r14, r21
 3f2:	51 e0       	ldi	r21, 0x01	; 1
 3f4:	f5 2e       	mov	r15, r21
 3f6:	ec 0e       	add	r14, r28
 3f8:	fd 1e       	adc	r15, r29
 3fa:	65 e1       	ldi	r22, 0x15	; 21
 3fc:	71 e0       	ldi	r23, 0x01	; 1
 3fe:	c7 01       	movw	r24, r14
 400:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 404:	8f e0       	ldi	r24, 0x0F	; 15
 406:	f7 01       	movw	r30, r14
 408:	84 8f       	std	Z+28, r24	; 0x1c
 40a:	65 e2       	ldi	r22, 0x25	; 37
 40c:	71 e0       	ldi	r23, 0x01	; 1
 40e:	c7 01       	movw	r24, r14
 410:	4d 96       	adiw	r24, 0x1d	; 29
 412:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 416:	65 e3       	ldi	r22, 0x35	; 53
 418:	71 e0       	ldi	r23, 0x01	; 1
 41a:	c7 01       	movw	r24, r14
 41c:	8d 96       	adiw	r24, 0x2d	; 45
 41e:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 422:	65 e4       	ldi	r22, 0x45	; 69
 424:	71 e0       	ldi	r23, 0x01	; 1
 426:	c7 01       	movw	r24, r14
 428:	cd 96       	adiw	r24, 0x3d	; 61
 42a:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 42e:	65 e5       	ldi	r22, 0x55	; 85
 430:	71 e0       	ldi	r23, 0x01	; 1
 432:	ce 01       	movw	r24, r28
 434:	88 57       	subi	r24, 0x78	; 120
 436:	9e 4f       	sbci	r25, 0xFE	; 254
 438:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 43c:	65 e6       	ldi	r22, 0x65	; 101
 43e:	71 e0       	ldi	r23, 0x01	; 1
 440:	ce 01       	movw	r24, r28
 442:	88 56       	subi	r24, 0x68	; 104
 444:	9e 4f       	sbci	r25, 0xFE	; 254
 446:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 44a:	65 e7       	ldi	r22, 0x75	; 117
 44c:	71 e0       	ldi	r23, 0x01	; 1
 44e:	ce 01       	movw	r24, r28
 450:	88 55       	subi	r24, 0x58	; 88
 452:	9e 4f       	sbci	r25, 0xFE	; 254
 454:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 458:	ce 01       	movw	r24, r28
 45a:	01 96       	adiw	r24, 0x01	; 1
 45c:	fe 01       	movw	r30, r28
 45e:	e8 53       	subi	r30, 0x38	; 56
 460:	fe 4f       	sbci	r31, 0xFE	; 254
 462:	91 83       	std	Z+1, r25	; 0x01
 464:	80 83       	st	Z, r24
 466:	8e 01       	movw	r16, r28
 468:	02 56       	subi	r16, 0x62	; 98
 46a:	1f 4f       	sbci	r17, 0xFF	; 255
 46c:	fe 01       	movw	r30, r28
 46e:	e6 53       	subi	r30, 0x36	; 54
 470:	fe 4f       	sbci	r31, 0xFE	; 254
 472:	11 83       	std	Z+1, r17	; 0x01
 474:	00 83       	st	Z, r16
 476:	fe 01       	movw	r30, r28
 478:	e4 53       	subi	r30, 0x34	; 52
 47a:	fe 4f       	sbci	r31, 0xFE	; 254
 47c:	11 82       	std	Z+1, r1	; 0x01
 47e:	10 82       	st	Z, r1
 480:	fe 01       	movw	r30, r28
 482:	e2 53       	subi	r30, 0x32	; 50
 484:	fe 4f       	sbci	r31, 0xFE	; 254
 486:	11 82       	std	Z+1, r1	; 0x01
 488:	10 82       	st	Z, r1
 48a:	fe 01       	movw	r30, r28
 48c:	e0 53       	subi	r30, 0x30	; 48
 48e:	fe 4f       	sbci	r31, 0xFE	; 254
 490:	11 82       	std	Z+1, r1	; 0x01
 492:	10 82       	st	Z, r1
 494:	fe 01       	movw	r30, r28
 496:	ee 52       	subi	r30, 0x2E	; 46
 498:	fe 4f       	sbci	r31, 0xFE	; 254
 49a:	11 82       	std	Z+1, r1	; 0x01
 49c:	10 82       	st	Z, r1
 49e:	26 e0       	ldi	r18, 0x06	; 6
 4a0:	fe 01       	movw	r30, r28
 4a2:	ea 52       	subi	r30, 0x2A	; 42
 4a4:	fe 4f       	sbci	r31, 0xFE	; 254
 4a6:	20 83       	st	Z, r18
 4a8:	fe 01       	movw	r30, r28
 4aa:	e9 52       	subi	r30, 0x29	; 41
 4ac:	fe 4f       	sbci	r31, 0xFE	; 254
 4ae:	10 82       	st	Z, r1
 4b0:	65 e8       	ldi	r22, 0x85	; 133
 4b2:	71 e0       	ldi	r23, 0x01	; 1
 4b4:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 4b8:	84 e0       	ldi	r24, 0x04	; 4
 4ba:	8d 8f       	std	Y+29, r24	; 0x1d
 4bc:	6a e8       	ldi	r22, 0x8A	; 138
 4be:	71 e0       	ldi	r23, 0x01	; 1
 4c0:	ce 01       	movw	r24, r28
 4c2:	4e 96       	adiw	r24, 0x1e	; 30
 4c4:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 4c8:	6a e9       	ldi	r22, 0x9A	; 154
 4ca:	71 e0       	ldi	r23, 0x01	; 1
 4cc:	ce 01       	movw	r24, r28
 4ce:	8e 96       	adiw	r24, 0x2e	; 46
 4d0:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 4d4:	fe 01       	movw	r30, r28
 4d6:	e2 57       	subi	r30, 0x72	; 114
 4d8:	ff 4f       	sbci	r31, 0xFF	; 255
 4da:	11 82       	std	Z+1, r1	; 0x01
 4dc:	10 82       	st	Z, r1
 4de:	fe 01       	movw	r30, r28
 4e0:	e0 57       	subi	r30, 0x70	; 112
 4e2:	ff 4f       	sbci	r31, 0xFF	; 255
 4e4:	f1 82       	std	Z+1, r15	; 0x01
 4e6:	e0 82       	st	Z, r14
 4e8:	82 e0       	ldi	r24, 0x02	; 2
 4ea:	fe 01       	movw	r30, r28
 4ec:	e4 56       	subi	r30, 0x64	; 100
 4ee:	ff 4f       	sbci	r31, 0xFF	; 255
 4f0:	80 83       	st	Z, r24
 4f2:	fe 01       	movw	r30, r28
 4f4:	e3 56       	subi	r30, 0x63	; 99
 4f6:	ff 4f       	sbci	r31, 0xFF	; 255
 4f8:	10 82       	st	Z, r1
 4fa:	6a ea       	ldi	r22, 0xAA	; 170
 4fc:	71 e0       	ldi	r23, 0x01	; 1
 4fe:	c8 01       	movw	r24, r16
 500:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 504:	8a e0       	ldi	r24, 0x0A	; 10
 506:	f8 01       	movw	r30, r16
 508:	84 8f       	std	Z+28, r24	; 0x1c
 50a:	65 eb       	ldi	r22, 0xB5	; 181
 50c:	71 e0       	ldi	r23, 0x01	; 1
 50e:	c8 01       	movw	r24, r16
 510:	4d 96       	adiw	r24, 0x1d	; 29
 512:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 516:	65 ec       	ldi	r22, 0xC5	; 197
 518:	71 e0       	ldi	r23, 0x01	; 1
 51a:	c8 01       	movw	r24, r16
 51c:	8d 96       	adiw	r24, 0x2d	; 45
 51e:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 522:	65 ed       	ldi	r22, 0xD5	; 213
 524:	71 e0       	ldi	r23, 0x01	; 1
 526:	c8 01       	movw	r24, r16
 528:	cd 96       	adiw	r24, 0x3d	; 61
 52a:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 52e:	65 ee       	ldi	r22, 0xE5	; 229
 530:	71 e0       	ldi	r23, 0x01	; 1
 532:	ce 01       	movw	r24, r28
 534:	85 51       	subi	r24, 0x15	; 21
 536:	9f 4f       	sbci	r25, 0xFF	; 255
 538:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 53c:	65 ef       	ldi	r22, 0xF5	; 245
 53e:	71 e0       	ldi	r23, 0x01	; 1
 540:	ce 01       	movw	r24, r28
 542:	85 50       	subi	r24, 0x05	; 5
 544:	9f 4f       	sbci	r25, 0xFF	; 255
 546:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 54a:	65 e0       	ldi	r22, 0x05	; 5
 54c:	72 e0       	ldi	r23, 0x02	; 2
 54e:	ce 01       	movw	r24, r28
 550:	85 5f       	subi	r24, 0xF5	; 245
 552:	9e 4f       	sbci	r25, 0xFE	; 254
 554:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 558:	6a e9       	ldi	r22, 0x9A	; 154
 55a:	71 e0       	ldi	r23, 0x01	; 1
 55c:	ce 01       	movw	r24, r28
 55e:	85 5e       	subi	r24, 0xE5	; 229
 560:	9e 4f       	sbci	r25, 0xFE	; 254
 562:	0e 94 86 05 	call	0xb0c	; 0xb0c <strcpy>
 566:	fe 01       	movw	r30, r28
 568:	e5 5d       	subi	r30, 0xD5	; 213
 56a:	fe 4f       	sbci	r31, 0xFE	; 254
 56c:	11 82       	std	Z+1, r1	; 0x01
 56e:	10 82       	st	Z, r1
 570:	fe 01       	movw	r30, r28
 572:	e3 5d       	subi	r30, 0xD3	; 211
 574:	fe 4f       	sbci	r31, 0xFE	; 254
 576:	11 82       	std	Z+1, r1	; 0x01
 578:	10 82       	st	Z, r1
 57a:	fe 01       	movw	r30, r28
 57c:	e1 5d       	subi	r30, 0xD1	; 209
 57e:	fe 4f       	sbci	r31, 0xFE	; 254
 580:	11 82       	std	Z+1, r1	; 0x01
 582:	10 82       	st	Z, r1
 584:	fe 01       	movw	r30, r28
 586:	ef 5c       	subi	r30, 0xCF	; 207
 588:	fe 4f       	sbci	r31, 0xFE	; 254
 58a:	11 82       	std	Z+1, r1	; 0x01
 58c:	10 82       	st	Z, r1
 58e:	fe 01       	movw	r30, r28
 590:	ed 5c       	subi	r30, 0xCD	; 205
 592:	fe 4f       	sbci	r31, 0xFE	; 254
 594:	11 82       	std	Z+1, r1	; 0x01
 596:	10 82       	st	Z, r1
 598:	fe 01       	movw	r30, r28
 59a:	eb 5c       	subi	r30, 0xCB	; 203
 59c:	fe 4f       	sbci	r31, 0xFE	; 254
 59e:	11 82       	std	Z+1, r1	; 0x01
 5a0:	10 82       	st	Z, r1
 5a2:	fe 01       	movw	r30, r28
 5a4:	e9 5c       	subi	r30, 0xC9	; 201
 5a6:	fe 4f       	sbci	r31, 0xFE	; 254
 5a8:	f1 82       	std	Z+1, r15	; 0x01
 5aa:	e0 82       	st	Z, r14
 5ac:	87 e0       	ldi	r24, 0x07	; 7
 5ae:	fe 01       	movw	r30, r28
 5b0:	e7 5c       	subi	r30, 0xC7	; 199
 5b2:	fe 4f       	sbci	r31, 0xFE	; 254
 5b4:	80 83       	st	Z, r24
 5b6:	fe 01       	movw	r30, r28
 5b8:	e6 5c       	subi	r30, 0xC6	; 198
 5ba:	fe 4f       	sbci	r31, 0xFE	; 254
 5bc:	10 82       	st	Z, r1
 5be:	f0 92 20 02 	sts	0x0220, r15
 5c2:	e0 92 1f 02 	sts	0x021F, r14
 5c6:	c7 01       	movw	r24, r14
 5c8:	0e 94 57 00 	call	0xae	; 0xae <drawMenue>
 5cc:	81 e0       	ldi	r24, 0x01	; 1
 5ce:	0e 94 6c 05 	call	0xad8	; 0xad8 <get_key_press>
 5d2:	88 23       	and	r24, r24
 5d4:	39 f1       	breq	.+78     	; 0x624 <main+0x3d6>
 5d6:	20 91 16 02 	lds	r18, 0x0216
 5da:	80 91 1f 02 	lds	r24, 0x021F
 5de:	90 91 20 02 	lds	r25, 0x0220
 5e2:	e2 2f       	mov	r30, r18
 5e4:	ff 27       	eor	r31, r31
 5e6:	e7 fd       	sbrc	r30, 7
 5e8:	f0 95       	com	r31
 5ea:	ee 0f       	add	r30, r30
 5ec:	ff 1f       	adc	r31, r31
 5ee:	e8 0f       	add	r30, r24
 5f0:	f9 1f       	adc	r31, r25
 5f2:	e5 57       	subi	r30, 0x75	; 117
 5f4:	ff 4f       	sbci	r31, 0xFF	; 255
 5f6:	01 90       	ld	r0, Z+
 5f8:	f0 81       	ld	r31, Z
 5fa:	e0 2d       	mov	r30, r0
 5fc:	30 97       	sbiw	r30, 0x00	; 0
 5fe:	89 f0       	breq	.+34     	; 0x622 <main+0x3d4>
 600:	22 23       	and	r18, r18
 602:	79 f0       	breq	.+30     	; 0x622 <main+0x3d4>
 604:	f0 93 20 02 	sts	0x0220, r31
 608:	e0 93 1f 02 	sts	0x021F, r30
 60c:	10 92 16 02 	sts	0x0216, r1
 610:	e4 56       	subi	r30, 0x64	; 100
 612:	ff 4f       	sbci	r31, 0xFF	; 255
 614:	10 82       	st	Z, r1
 616:	80 91 1f 02 	lds	r24, 0x021F
 61a:	90 91 20 02 	lds	r25, 0x0220
 61e:	0e 94 57 00 	call	0xae	; 0xae <drawMenue>
 622:	2a 9a       	sbi	0x05, 2	; 5
 624:	82 e0       	ldi	r24, 0x02	; 2
 626:	0e 94 6c 05 	call	0xad8	; 0xad8 <get_key_press>
 62a:	88 23       	and	r24, r24
 62c:	29 f4       	brne	.+10     	; 0x638 <main+0x3ea>
 62e:	82 e0       	ldi	r24, 0x02	; 2
 630:	0e 94 79 05 	call	0xaf2	; 0xaf2 <get_key_rpt>
 634:	88 23       	and	r24, r24
 636:	d9 f0       	breq	.+54     	; 0x66e <main+0x420>
 638:	20 91 16 02 	lds	r18, 0x0216
 63c:	2f 5f       	subi	r18, 0xFF	; 255
 63e:	20 93 16 02 	sts	0x0216, r18
 642:	e0 91 1f 02 	lds	r30, 0x021F
 646:	f0 91 20 02 	lds	r31, 0x0220
 64a:	33 27       	eor	r19, r19
 64c:	27 fd       	sbrc	r18, 7
 64e:	30 95       	com	r19
 650:	e5 56       	subi	r30, 0x65	; 101
 652:	ff 4f       	sbci	r31, 0xFF	; 255
 654:	80 81       	ld	r24, Z
 656:	eb 59       	subi	r30, 0x9B	; 155
 658:	f0 40       	sbci	r31, 0x00	; 0
 65a:	99 27       	eor	r25, r25
 65c:	82 17       	cp	r24, r18
 65e:	93 07       	cpc	r25, r19
 660:	1c f4       	brge	.+6      	; 0x668 <main+0x41a>
 662:	81 e0       	ldi	r24, 0x01	; 1
 664:	80 93 16 02 	sts	0x0216, r24
 668:	cf 01       	movw	r24, r30
 66a:	0e 94 bb 00 	call	0x176	; 0x176 <reDrawMenue>
 66e:	84 e0       	ldi	r24, 0x04	; 4
 670:	0e 94 6c 05 	call	0xad8	; 0xad8 <get_key_press>
 674:	88 23       	and	r24, r24
 676:	31 f4       	brne	.+12     	; 0x684 <main+0x436>
 678:	84 e0       	ldi	r24, 0x04	; 4
 67a:	0e 94 79 05 	call	0xaf2	; 0xaf2 <get_key_rpt>
 67e:	88 23       	and	r24, r24
 680:	09 f4       	brne	.+2      	; 0x684 <main+0x436>
 682:	a4 cf       	rjmp	.-184    	; 0x5cc <main+0x37e>
 684:	80 91 16 02 	lds	r24, 0x0216
 688:	81 50       	subi	r24, 0x01	; 1
 68a:	80 93 16 02 	sts	0x0216, r24
 68e:	18 16       	cp	r1, r24
 690:	4c f0       	brlt	.+18     	; 0x6a4 <main+0x456>
 692:	e0 91 1f 02 	lds	r30, 0x021F
 696:	f0 91 20 02 	lds	r31, 0x0220
 69a:	e5 56       	subi	r30, 0x65	; 101
 69c:	ff 4f       	sbci	r31, 0xFF	; 255
 69e:	80 81       	ld	r24, Z
 6a0:	80 93 16 02 	sts	0x0216, r24
 6a4:	80 91 1f 02 	lds	r24, 0x021F
 6a8:	90 91 20 02 	lds	r25, 0x0220
 6ac:	0e 94 bb 00 	call	0x176	; 0x176 <reDrawMenue>
 6b0:	8d cf       	rjmp	.-230    	; 0x5cc <main+0x37e>

000006b2 <toggle_e>:
*************************************************************************/
#define delay(us)  _delayFourCycles( ( ( 1*(F_CPU/4000) )*us)/1000 )

static void toggle_e(void)
{
 6b2:	21 e0       	ldi	r18, 0x01	; 1
 6b4:	30 e0       	ldi	r19, 0x00	; 0
 6b6:	00 90 21 02 	lds	r0, 0x0221
 6ba:	02 c0       	rjmp	.+4      	; 0x6c0 <toggle_e+0xe>
 6bc:	22 0f       	add	r18, r18
 6be:	33 1f       	adc	r19, r19
 6c0:	0a 94       	dec	r0
 6c2:	e2 f7       	brpl	.-8      	; 0x6bc <toggle_e+0xa>
 6c4:	88 b1       	in	r24, 0x08	; 8
 6c6:	82 2b       	or	r24, r18
 6c8:	88 b9       	out	0x08, r24	; 8
    lcd_e_high();
    lcd_e_delay();
 6ca:	00 c0       	rjmp	.+0      	; 0x6cc <toggle_e+0x1a>
    lcd_e_low();
 6cc:	92 2f       	mov	r25, r18
 6ce:	90 95       	com	r25
 6d0:	88 b1       	in	r24, 0x08	; 8
 6d2:	89 23       	and	r24, r25
 6d4:	88 b9       	out	0x08, r24	; 8
 6d6:	08 95       	ret

000006d8 <lcd_write>:
}

static void lcd_write(uint8_t data,uint8_t rs) 
{
 6d8:	cf 93       	push	r28
 6da:	c8 2f       	mov	r28, r24
	if (rs)
 6dc:	66 23       	and	r22, r22
 6de:	11 f0       	breq	.+4      	; 0x6e4 <lcd_write+0xc>
	{   /* write data        (RS=1, RW=0) */
		lcd_rs_high();
 6e0:	40 9a       	sbi	0x08, 0	; 8
 6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <lcd_write+0xe>
	}
	else
	{    /* write instruction (RS=0, RW=0) */
		lcd_rs_low();
 6e4:	40 98       	cbi	0x08, 0	; 8
	}
  
	lcd_rw_low();
 6e6:	41 98       	cbi	0x08, 1	; 8

    
	/* configure data pins as output */
	DDROFPORT(LCD_DATA_PORT) |= 0x0F << LCD_DATA_OFFSET;
 6e8:	87 b1       	in	r24, 0x07	; 7
 6ea:	80 6f       	ori	r24, 0xF0	; 240
 6ec:	87 b9       	out	0x07, r24	; 7

	/* output high nibble first */
	LCD_DATA_PORT = (LCD_DATA_PORT & (~(0x0F << LCD_DATA_OFFSET))) | ((data & 0xF0) >> (4-LCD_DATA_OFFSET));
 6ee:	88 b1       	in	r24, 0x08	; 8
 6f0:	8f 70       	andi	r24, 0x0F	; 15
 6f2:	9c 2f       	mov	r25, r28
 6f4:	90 7f       	andi	r25, 0xF0	; 240
 6f6:	89 2b       	or	r24, r25
 6f8:	88 b9       	out	0x08, r24	; 8
	toggle_e();
 6fa:	0e 94 59 03 	call	0x6b2	; 0x6b2 <toggle_e>

	/* output low nibble */
	LCD_DATA_PORT = (LCD_DATA_PORT & (~(0x0F << LCD_DATA_OFFSET))) | ((data & 0x0F) << LCD_DATA_OFFSET);
 6fe:	28 b1       	in	r18, 0x08	; 8
 700:	2f 70       	andi	r18, 0x0F	; 15
 702:	8c 2f       	mov	r24, r28
 704:	99 27       	eor	r25, r25
 706:	8f 70       	andi	r24, 0x0F	; 15
 708:	90 70       	andi	r25, 0x00	; 0
 70a:	34 e0       	ldi	r19, 0x04	; 4
 70c:	88 0f       	add	r24, r24
 70e:	99 1f       	adc	r25, r25
 710:	3a 95       	dec	r19
 712:	e1 f7       	brne	.-8      	; 0x70c <lcd_write+0x34>
 714:	28 2b       	or	r18, r24
 716:	28 b9       	out	0x08, r18	; 8
	toggle_e();
 718:	0e 94 59 03 	call	0x6b2	; 0x6b2 <toggle_e>
  
	/* all data pins high (inactive) */
	LCD_DATA_PORT = (LCD_DATA_PORT & (~(0x0F << LCD_DATA_OFFSET))) | (0x0F << LCD_DATA_OFFSET);
 71c:	88 b1       	in	r24, 0x08	; 8
 71e:	80 6f       	ori	r24, 0xF0	; 240
 720:	88 b9       	out	0x08, r24	; 8
 722:	cf 91       	pop	r28
 724:	08 95       	ret

00000726 <lcd_read>:
}

static unsigned char lcd_read(unsigned char rs) 
{
 726:	88 23       	and	r24, r24
 728:	11 f0       	breq	.+4      	; 0x72e <lcd_read+0x8>
    unsigned char data;
    
    if (rs)
      lcd_rs_high();                       /* RS=1: read data      */
 72a:	40 9a       	sbi	0x08, 0	; 8
 72c:	01 c0       	rjmp	.+2      	; 0x730 <lcd_read+0xa>
		else
      lcd_rs_low();                        /* RS=0: read busy flag */
 72e:	40 98       	cbi	0x08, 0	; 8
    
    lcd_rw_high();                           /* RW=1  read mode      */
 730:	41 9a       	sbi	0x08, 1	; 8
    
    DDROFPORT(LCD_DATA_PORT)=DDROFPORT(LCD_DATA_PORT) & (~(0x0F << LCD_DATA_OFFSET)); /* configure data pins as input */
 732:	87 b1       	in	r24, 0x07	; 7
 734:	8f 70       	andi	r24, 0x0F	; 15
 736:	87 b9       	out	0x07, r24	; 7
        
    lcd_e_high();
 738:	21 e0       	ldi	r18, 0x01	; 1
 73a:	30 e0       	ldi	r19, 0x00	; 0
 73c:	00 90 21 02 	lds	r0, 0x0221
 740:	02 c0       	rjmp	.+4      	; 0x746 <lcd_read+0x20>
 742:	22 0f       	add	r18, r18
 744:	33 1f       	adc	r19, r19
 746:	0a 94       	dec	r0
 748:	e2 f7       	brpl	.-8      	; 0x742 <lcd_read+0x1c>
 74a:	88 b1       	in	r24, 0x08	; 8
 74c:	82 2b       	or	r24, r18
 74e:	88 b9       	out	0x08, r24	; 8
    lcd_e_delay();        
 750:	00 c0       	rjmp	.+0      	; 0x752 <lcd_read+0x2c>
    data = (PINOFPORT(LCD_DATA_PORT) << (4-LCD_DATA_OFFSET)) & 0xF0;     /* read high nibble first */
 752:	96 b1       	in	r25, 0x06	; 6
 754:	90 7f       	andi	r25, 0xF0	; 240
    lcd_e_low();
 756:	42 2f       	mov	r20, r18
 758:	40 95       	com	r20
 75a:	88 b1       	in	r24, 0x08	; 8
 75c:	84 23       	and	r24, r20
 75e:	88 b9       	out	0x08, r24	; 8
       
    lcd_e_delay();                       /* Enable 500ns low       */
 760:	00 c0       	rjmp	.+0      	; 0x762 <lcd_read+0x3c>
        
    lcd_e_high();
 762:	88 b1       	in	r24, 0x08	; 8
 764:	82 2b       	or	r24, r18
 766:	88 b9       	out	0x08, r24	; 8
    lcd_e_delay();
 768:	00 c0       	rjmp	.+0      	; 0x76a <lcd_read+0x44>
    data |= (PINOFPORT(LCD_DATA_PORT) >> LCD_DATA_OFFSET) & 0x0F;    /* read low nibble        */
 76a:	86 b1       	in	r24, 0x06	; 6
 76c:	82 95       	swap	r24
 76e:	8f 70       	andi	r24, 0x0F	; 15
 770:	98 2b       	or	r25, r24
    lcd_e_low();
 772:	88 b1       	in	r24, 0x08	; 8
 774:	84 23       	and	r24, r20
 776:	88 b9       	out	0x08, r24	; 8
    
    return data;
}
 778:	89 2f       	mov	r24, r25
 77a:	99 27       	eor	r25, r25
 77c:	08 95       	ret

0000077e <lcd_waitbusy>:

static unsigned char lcd_waitbusy(void)
{
 77e:	80 e0       	ldi	r24, 0x00	; 0
 780:	0e 94 93 03 	call	0x726	; 0x726 <lcd_read>
 784:	88 23       	and	r24, r24
 786:	dc f3       	brlt	.-10     	; 0x77e <lcd_waitbusy>
 788:	00 c0       	rjmp	.+0      	; 0x78a <lcd_waitbusy+0xc>
    register unsigned char c;
    
    /* wait until busy flag is cleared */
    while ( (c=lcd_read(0)) & (1<<LCD_BUSY)) {}
    
    /* the address counter is updated 4us after the busy flag is cleared */
    delay(2);

    /* now read the address counter */
    return (lcd_read(0));  // return address counter
 78a:	80 e0       	ldi	r24, 0x00	; 0
 78c:	0e 94 93 03 	call	0x726	; 0x726 <lcd_read>
}
 790:	99 27       	eor	r25, r25
 792:	08 95       	ret

00000794 <lcd_command>:

static inline void lcd_newline(uint8_t pos)
{
    register uint8_t addressCounter;
	
	if (pos < 27)
        addressCounter = 64;
    else
	{
		addressCounter = 0;
		if (active_e == LCD_PIN_E1)
			active_e=LCD_PIN_E2;
		else
			active_e=LCD_PIN_E1;
	}
    lcd_command(LCD_SET_DDRAM + addressCounter);
}


void lcd_command(unsigned char cmd)
{
 794:	1f 93       	push	r17
 796:	18 2f       	mov	r17, r24
    lcd_waitbusy();
 798:	0e 94 bf 03 	call	0x77e	; 0x77e <lcd_waitbusy>
    lcd_write(cmd, 0);
 79c:	60 e0       	ldi	r22, 0x00	; 0
 79e:	81 2f       	mov	r24, r17
 7a0:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <lcd_write>
 7a4:	1f 91       	pop	r17
 7a6:	08 95       	ret

000007a8 <lcd_gotoxy>:
}


void lcd_gotoxy(uint8_t x, uint8_t y)
{
 7a8:	98 2f       	mov	r25, r24
	if (y > 1)
 7aa:	62 30       	cpi	r22, 0x02	; 2
 7ac:	28 f0       	brcs	.+10     	; 0x7b8 <lcd_gotoxy+0x10>
	{
		active_e=LCD_PIN_E1;
 7ae:	83 e0       	ldi	r24, 0x03	; 3
 7b0:	80 93 21 02 	sts	0x0221, r24
		y-=2;
 7b4:	62 50       	subi	r22, 0x02	; 2
 7b6:	03 c0       	rjmp	.+6      	; 0x7be <lcd_gotoxy+0x16>
	}
	else
		active_e=LCD_PIN_E2;
 7b8:	82 e0       	ldi	r24, 0x02	; 2
 7ba:	80 93 21 02 	sts	0x0221, r24
		
	lcd_command(LCD_SET_DDRAM + x + (y * 64));	
 7be:	62 95       	swap	r22
 7c0:	66 0f       	add	r22, r22
 7c2:	66 0f       	add	r22, r22
 7c4:	60 7c       	andi	r22, 0xC0	; 192
 7c6:	69 0f       	add	r22, r25
 7c8:	86 2f       	mov	r24, r22
 7ca:	80 58       	subi	r24, 0x80	; 128
 7cc:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
 7d0:	08 95       	ret

000007d2 <lcd_putc>:
}


void lcd_putc(char c)
{
 7d2:	cf 93       	push	r28
 7d4:	c8 2f       	mov	r28, r24
    uint8_t pos;


    pos = lcd_waitbusy();   // read busy-flag and address counter
 7d6:	0e 94 bf 03 	call	0x77e	; 0x77e <lcd_waitbusy>
    if (c=='\n')
 7da:	ca 30       	cpi	r28, 0x0A	; 10
 7dc:	99 f4       	brne	.+38     	; 0x804 <lcd_putc+0x32>
 7de:	8b 31       	cpi	r24, 0x1B	; 27
 7e0:	10 f4       	brcc	.+4      	; 0x7e6 <lcd_putc+0x14>
 7e2:	90 e4       	ldi	r25, 0x40	; 64
 7e4:	0a c0       	rjmp	.+20     	; 0x7fa <lcd_putc+0x28>
 7e6:	90 e0       	ldi	r25, 0x00	; 0
 7e8:	80 91 21 02 	lds	r24, 0x0221
 7ec:	83 30       	cpi	r24, 0x03	; 3
 7ee:	11 f4       	brne	.+4      	; 0x7f4 <lcd_putc+0x22>
 7f0:	82 e0       	ldi	r24, 0x02	; 2
 7f2:	01 c0       	rjmp	.+2      	; 0x7f6 <lcd_putc+0x24>
 7f4:	83 e0       	ldi	r24, 0x03	; 3
 7f6:	80 93 21 02 	sts	0x0221, r24
 7fa:	89 2f       	mov	r24, r25
 7fc:	80 58       	subi	r24, 0x80	; 128
 7fe:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
 802:	1a c0       	rjmp	.+52     	; 0x838 <lcd_putc+0x66>
    {
        lcd_newline(pos);
    }
    else
    {
#if LCD_WORD_WRAP==1
		if (pos == 27)
 804:	8b 31       	cpi	r24, 0x1B	; 27
 806:	19 f4       	brne	.+6      	; 0x80e <lcd_putc+0x3c>
		{
			lcd_write(LCD_SET_DDRAM + 64, 0);
 808:	60 e0       	ldi	r22, 0x00	; 0
 80a:	80 ec       	ldi	r24, 0xC0	; 192
 80c:	0d c0       	rjmp	.+26     	; 0x828 <lcd_putc+0x56>
		}
		else
		{
			if (pos == (64 + 27))
 80e:	8b 35       	cpi	r24, 0x5B	; 91
 810:	69 f4       	brne	.+26     	; 0x82c <lcd_putc+0x5a>
			{
				if (active_e == LCD_PIN_E1)
 812:	80 91 21 02 	lds	r24, 0x0221
 816:	83 30       	cpi	r24, 0x03	; 3
 818:	11 f4       	brne	.+4      	; 0x81e <lcd_putc+0x4c>
				{
					active_e=LCD_PIN_E2;
 81a:	82 e0       	ldi	r24, 0x02	; 2
 81c:	01 c0       	rjmp	.+2      	; 0x820 <lcd_putc+0x4e>
				}
				else
				{
					active_e=LCD_PIN_E1;
 81e:	83 e0       	ldi	r24, 0x03	; 3
 820:	80 93 21 02 	sts	0x0221, r24
				}
				lcd_write(LCD_SET_DDRAM + 0, 0);
 824:	60 e0       	ldi	r22, 0x00	; 0
 826:	80 e8       	ldi	r24, 0x80	; 128
 828:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <lcd_write>
			}
		}
		
        lcd_waitbusy();
 82c:	0e 94 bf 03 	call	0x77e	; 0x77e <lcd_waitbusy>
#endif
        lcd_write(c, 1);
 830:	61 e0       	ldi	r22, 0x01	; 1
 832:	8c 2f       	mov	r24, r28
 834:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <lcd_write>
 838:	cf 91       	pop	r28
 83a:	08 95       	ret

0000083c <lcd_puts>:
    }
}


void lcd_puts(const char *s)
{
 83c:	cf 93       	push	r28
 83e:	df 93       	push	r29
 840:	ec 01       	movw	r28, r24
  register char c;

  while ( (c = *s++) )
  {
    lcd_putc(c);
 842:	89 91       	ld	r24, Y+
 844:	88 23       	and	r24, r24
 846:	29 f0       	breq	.+10     	; 0x852 <lcd_puts+0x16>
 848:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 84c:	89 91       	ld	r24, Y+
 84e:	88 23       	and	r24, r24
 850:	d9 f7       	brne	.-10     	; 0x848 <lcd_puts+0xc>
 852:	df 91       	pop	r29
 854:	cf 91       	pop	r28
 856:	08 95       	ret

00000858 <lcd_puts_P>:
  }
}


void lcd_puts_P(const char *progmem_s)
{
 858:	cf 93       	push	r28
 85a:	df 93       	push	r29
 85c:	ec 01       	movw	r28, r24
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
 85e:	fc 01       	movw	r30, r24
 860:	21 96       	adiw	r28, 0x01	; 1
 862:	84 91       	lpm	r24, Z
 864:	88 23       	and	r24, r24
 866:	39 f0       	breq	.+14     	; 0x876 <lcd_puts_P+0x1e>
 868:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <lcd_putc>
 86c:	fe 01       	movw	r30, r28
 86e:	21 96       	adiw	r28, 0x01	; 1
 870:	84 91       	lpm	r24, Z
 872:	88 23       	and	r24, r24
 874:	c9 f7       	brne	.-14     	; 0x868 <lcd_puts_P+0x10>
 876:	df 91       	pop	r29
 878:	cf 91       	pop	r28
 87a:	08 95       	ret

0000087c <lcd_clrscr>:
    }
}


void lcd_clrscr(void)
{
 87c:	82 e0       	ldi	r24, 0x02	; 2
 87e:	80 93 21 02 	sts	0x0221, r24
	active_e=LCD_PIN_E2;
	lcd_command(LCD_CLEAR);
 882:	81 e0       	ldi	r24, 0x01	; 1
 884:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
	active_e=LCD_PIN_E1;
 888:	83 e0       	ldi	r24, 0x03	; 3
 88a:	80 93 21 02 	sts	0x0221, r24
	lcd_command(LCD_CLEAR);
 88e:	81 e0       	ldi	r24, 0x01	; 1
 890:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
 894:	08 95       	ret

00000896 <init_controller>:
}


void init_controller(unsigned char cmd)
{
 896:	0f 93       	push	r16
 898:	1f 93       	push	r17
 89a:	08 2f       	mov	r16, r24
/* initial write to lcd is 8bit */
	LCD_DATA_PORT=(LCD_DATA_PORT & (~(0x0F << LCD_DATA_OFFSET))) | (0x03 << LCD_DATA_OFFSET);
 89c:	1f e0       	ldi	r17, 0x0F	; 15
 89e:	88 b1       	in	r24, 0x08	; 8
 8a0:	81 23       	and	r24, r17
 8a2:	80 63       	ori	r24, 0x30	; 48
 8a4:	88 b9       	out	0x08, r24	; 8
	toggle_e();
 8a6:	0e 94 59 03 	call	0x6b2	; 0x6b2 <toggle_e>
 8aa:	80 ee       	ldi	r24, 0xE0	; 224
 8ac:	94 e0       	ldi	r25, 0x04	; 4
 8ae:	01 97       	sbiw	r24, 0x01	; 1
 8b0:	f1 f7       	brne	.-4      	; 0x8ae <init_controller+0x18>
	delay(4992);         /* delay, busy flag can't be checked here */

	/* repeat last command */ 
	toggle_e();      
 8b2:	0e 94 59 03 	call	0x6b2	; 0x6b2 <toggle_e>
 8b6:	80 e1       	ldi	r24, 0x10	; 16
 8b8:	90 e0       	ldi	r25, 0x00	; 0
 8ba:	01 97       	sbiw	r24, 0x01	; 1
 8bc:	f1 f7       	brne	.-4      	; 0x8ba <init_controller+0x24>
	delay(64);           /* delay, busy flag can't be checked here */
    
	/* repeat last command a third time */
	toggle_e();      
 8be:	0e 94 59 03 	call	0x6b2	; 0x6b2 <toggle_e>
 8c2:	80 e1       	ldi	r24, 0x10	; 16
 8c4:	90 e0       	ldi	r25, 0x00	; 0
 8c6:	01 97       	sbiw	r24, 0x01	; 1
 8c8:	f1 f7       	brne	.-4      	; 0x8c6 <init_controller+0x30>
	delay(64);           /* delay, busy flag can't be checked here */

	/* now configure for 4bit mode */
	LCD_DATA_PORT=(LCD_DATA_PORT & (~(0x0F << LCD_DATA_OFFSET))) | (0x02 << LCD_DATA_OFFSET); // LCD_FUNCTION_4BIT_1LINE>>4
 8ca:	88 b1       	in	r24, 0x08	; 8
 8cc:	81 23       	and	r24, r17
 8ce:	80 62       	ori	r24, 0x20	; 32
 8d0:	88 b9       	out	0x08, r24	; 8
	toggle_e();
 8d2:	0e 94 59 03 	call	0x6b2	; 0x6b2 <toggle_e>
 8d6:	80 e1       	ldi	r24, 0x10	; 16
 8d8:	90 e0       	ldi	r25, 0x00	; 0
 8da:	01 97       	sbiw	r24, 0x01	; 1
 8dc:	f1 f7       	brne	.-4      	; 0x8da <init_controller+0x44>
	delay(64);           /* some displays need this additional delay */
	
	/* from now the LCD only accepts 4 bit I/O, we can use lcd_command() */    
	lcd_command(LCD_FUNCTION_4BIT_2LINES);
 8de:	88 e2       	ldi	r24, 0x28	; 40
 8e0:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
	lcd_command(LCD_DISP_OFF);              /* display off                  */
 8e4:	88 e0       	ldi	r24, 0x08	; 8
 8e6:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
	lcd_command(LCD_CLEAR);                 /* display clear                */ 
 8ea:	81 e0       	ldi	r24, 0x01	; 1
 8ec:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
	lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 8f0:	86 e0       	ldi	r24, 0x06	; 6
 8f2:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
	lcd_command(cmd);		                /* display/cursor control       */
 8f6:	80 2f       	mov	r24, r16
 8f8:	0e 94 ca 03 	call	0x794	; 0x794 <lcd_command>
 8fc:	1f 91       	pop	r17
 8fe:	0f 91       	pop	r16
 900:	08 95       	ret

00000902 <lcd_init>:
}

void lcd_init(unsigned char cmd)
{
 902:	1f 93       	push	r17
 904:	18 2f       	mov	r17, r24
	//set IO directions
	DDROFPORT(LCD_DATA_PORT) |= 0x0F << LCD_DATA_OFFSET;
 906:	87 b1       	in	r24, 0x07	; 7
 908:	80 6f       	ori	r24, 0xF0	; 240
 90a:	87 b9       	out	0x07, r24	; 7
	DDROFPORT(LCD_CTRL_PORT) |= 1<<LCD_PIN_RS;
 90c:	38 9a       	sbi	0x07, 0	; 7
	DDROFPORT(LCD_CTRL_PORT) |= 1<<LCD_PIN_RW;
 90e:	39 9a       	sbi	0x07, 1	; 7
	DDROFPORT(LCD_CTRL_PORT) |= 1<<LCD_PIN_E1;
 910:	3b 9a       	sbi	0x07, 3	; 7
	DDROFPORT(LCD_CTRL_PORT) |= 1<<LCD_PIN_E2;
 912:	3a 9a       	sbi	0x07, 2	; 7
 914:	80 ea       	ldi	r24, 0xA0	; 160
 916:	9f e0       	ldi	r25, 0x0F	; 15
 918:	01 97       	sbiw	r24, 0x01	; 1
 91a:	f1 f7       	brne	.-4      	; 0x918 <lcd_init+0x16>
	  
	  
	//initialize lcd in 4 bit mode
	delay(16000);
	
	active_e = LCD_PIN_E1;
 91c:	83 e0       	ldi	r24, 0x03	; 3
 91e:	80 93 21 02 	sts	0x0221, r24
	init_controller(cmd);
 922:	81 2f       	mov	r24, r17
 924:	0e 94 4b 04 	call	0x896	; 0x896 <init_controller>
	active_e = LCD_PIN_E2;
 928:	82 e0       	ldi	r24, 0x02	; 2
 92a:	80 93 21 02 	sts	0x0221, r24
	init_controller(cmd);
 92e:	81 2f       	mov	r24, r17
 930:	0e 94 4b 04 	call	0x896	; 0x896 <init_controller>
 934:	1f 91       	pop	r17
 936:	08 95       	ret

00000938 <timer2_init>:
  nichts

*****************************************************************************/
void timer2_init(void)
{
 938:	83 ec       	ldi	r24, 0xC3	; 195
 93a:	80 93 b0 00 	sts	0x00B0, r24
	/* Timer2 auf 36 kHz eingestellt. */
	//TCCR2 = (1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21) | (1 << CS21);
	TCCR2A = (1 << WGM20) | (1 << WGM21) | (1 << COM2A0) | (1 << COM2A1);
	TCCR2B = (1 << CS21);
 93e:	82 e0       	ldi	r24, 0x02	; 2
 940:	80 93 b1 00 	sts	0x00B1, r24

	/* Interrupts für Timer2 aktivieren */	
	TIMSK2 |= (1<<TOIE2);
 944:	e0 e7       	ldi	r30, 0x70	; 112
 946:	f0 e0       	ldi	r31, 0x00	; 0
 948:	80 81       	ld	r24, Z
 94a:	81 60       	ori	r24, 0x01	; 1
 94c:	80 83       	st	Z, r24
 94e:	08 95       	ret

00000950 <Gettime>:
}	

/****************************************************************************/
/*!
  \brief
  Gibt die aktuelle Zeit in ms zurueck.

  Die vergangene Zeit seit dem Einschalten\n
  Genauer: nachdem der Interrupt Timer2 aktiviert wurde.\n

  \param
  keine

  \return
  Einschaltzeit in Millisekunden (Bereich: unsigned long 0..286331153)\n
  Das sind ca. 79.5 Stunden. Diese Zeitangabe reicht bis der Accu leer ist.

  \par  Beispiel:
  (Nur zur Demonstration der Parameter/Returnwerte)
  \code
  // Alle 500 ms die Front-LED umschalten.
  unsigned long zeit;
  unsigned char on_off = TRUE;

  zeit = Gettime ();
  while (1)
  {
    if (Gettime () > zeit + 500)
    {
      zeit = Gettime ();
      FrontLED (on_off);
      on_off ^= 1;
    }
  }
  \endcode
*****************************************************************************/
unsigned long Gettime (void)
{
 950:	60 91 1b 02 	lds	r22, 0x021B
 954:	70 91 1c 02 	lds	r23, 0x021C
 958:	80 91 1d 02 	lds	r24, 0x021D
 95c:	90 91 1e 02 	lds	r25, 0x021E
 960:	20 91 1a 02 	lds	r18, 0x021A
 964:	98 2f       	mov	r25, r24
 966:	87 2f       	mov	r24, r23
 968:	76 2f       	mov	r23, r22
 96a:	66 27       	eor	r22, r22
 96c:	62 0f       	add	r22, r18
 96e:	71 1d       	adc	r23, r1
 970:	81 1d       	adc	r24, r1
 972:	91 1d       	adc	r25, r1
 974:	24 e2       	ldi	r18, 0x24	; 36
 976:	30 e0       	ldi	r19, 0x00	; 0
 978:	40 e0       	ldi	r20, 0x00	; 0
 97a:	50 e0       	ldi	r21, 0x00	; 0
 97c:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__udivmodsi4>
  return ((timebase * 256) + count36kHz) / 36;
}
 980:	ca 01       	movw	r24, r20
 982:	b9 01       	movw	r22, r18
 984:	08 95       	ret

00000986 <sleep>:

/****************************************************************************/
/*!
  \brief
  Wartefunktion.

  Die maximale Wartezeit betraegt 7ms. Fuer laengere Wartezeiten siehe Msleep().\n
  Diese Funktion nutzt den Timer 2-Interrupt um ein 'zeitgefuehl' zu erhalten.\n
  Der Interrupt wird mit 36 kHz, durch die Init()-Funktion initialisiert,\n
  aufgerufen und zaehlt dort die globale Variablen \b count36kHz weiter.\n
  Diese Funktion nutzt diesen Zaehler und berechnet daraus mit dem uebergeben\n
  Parameter den Zeitpunkt wann die Pausenzeit erreicht ist, Danach bricht sie\n
  ab, und im Hauptprogramm ist eben eine Wartezeit eingelegt worden.

  \param[in]
  time36kHz Wartezeit x/36kHz (sec)

  \return
  nichts

  \par  Beispiel:
  (Nur zur Demonstration der Parameter/Returnwerte)
  \code
  // 1 Millisekunde warten
  Sleep (36);
  \endcode
*****************************************************************************/
void sleep (
  unsigned char time36kHz)
{
 986:	90 91 1a 02 	lds	r25, 0x021A
 98a:	98 0f       	add	r25, r24
  unsigned char ziel = (time36kHz + count36kHz) & 0x00FF;

  while (count36kHz != ziel)
 98c:	80 91 1a 02 	lds	r24, 0x021A
 990:	89 17       	cp	r24, r25
 992:	e1 f7       	brne	.-8      	; 0x98c <sleep+0x6>
 994:	08 95       	ret

00000996 <__vector_11>:
    ;
}



/****************************************************************************/
/*!
  \brief
  Wartefunktion in ms.

  Diese Funktion nutzt die Sleep()-Funktion um mit dem uebergeben Parameter\n
  Pausen in ms-Einheiten zu erhalten.

  \param [in]
  dauer Wartezeit in Millisekunden.

  \return
  nichts

  \par  Beispiel:
  (Nur zur Demonstration der Parameter/Returnwerte)
  \code
  // 1.5 Sekunde warten
  Msleep (1500);
  \endcode
*****************************************************************************/
void msleep (int dauer)
{
  int z;
  for (z = 0; z < dauer; z++)	// z-mal ..
    sleep (36);					// ..eine ms warten
}

/****************************************************************************/
/*!
  \brief
  Interrupt-Funktion fuer Timer-2-Ueberlauf.

  \param
  keine

  \return
  nichts

  \see
  count36kHz, timebase

  \par
  Der zum Timer gehoerende Zaehler TCNT2 wird so justiert, dass damit die\n
  gewuenschten 36 kHz erreicht werden.\n
  Fuer die Zeitfunktionen werden die globalen Variablen count36kHz und\n
  timebase hochgezaehlt.
*****************************************************************************/
ISR(TIMER2_OVF_vect) /* veraltet: SIGNAL(SIG_OVERFLOW1) */
{
 996:	1f 92       	push	r1
 998:	0f 92       	push	r0
 99a:	0f b6       	in	r0, 0x3f	; 63
 99c:	0f 92       	push	r0
 99e:	11 24       	eor	r1, r1
 9a0:	2f 93       	push	r18
 9a2:	3f 93       	push	r19
 9a4:	4f 93       	push	r20
 9a6:	5f 93       	push	r21
 9a8:	6f 93       	push	r22
 9aa:	7f 93       	push	r23
 9ac:	8f 93       	push	r24
 9ae:	9f 93       	push	r25
 9b0:	af 93       	push	r26
 9b2:	bf 93       	push	r27
 9b4:	ef 93       	push	r30
 9b6:	ff 93       	push	r31
    /* erhöht den Wert des Timers um Ihn alle 36kHz überlaufen zu lassen */
	TCNT2 += 0xD7;
 9b8:	80 91 b2 00 	lds	r24, 0x00B2
 9bc:	89 52       	subi	r24, 0x29	; 41
 9be:	80 93 b2 00 	sts	0x00B2, r24
	
	/* Globalen counter erhöhen */
	count36kHz++;
 9c2:	80 91 1a 02 	lds	r24, 0x021A
 9c6:	8f 5f       	subi	r24, 0xFF	; 255
 9c8:	80 93 1a 02 	sts	0x021A, r24
	
	/* beim Überlauf globale Zeit erhöhen */
	if(!count36kHz){
 9cc:	80 91 1a 02 	lds	r24, 0x021A
 9d0:	88 23       	and	r24, r24
 9d2:	99 f4       	brne	.+38     	; 0x9fa <__vector_11+0x64>
		timebase++;
 9d4:	80 91 1b 02 	lds	r24, 0x021B
 9d8:	90 91 1c 02 	lds	r25, 0x021C
 9dc:	a0 91 1d 02 	lds	r26, 0x021D
 9e0:	b0 91 1e 02 	lds	r27, 0x021E
 9e4:	01 96       	adiw	r24, 0x01	; 1
 9e6:	a1 1d       	adc	r26, r1
 9e8:	b1 1d       	adc	r27, r1
 9ea:	80 93 1b 02 	sts	0x021B, r24
 9ee:	90 93 1c 02 	sts	0x021C, r25
 9f2:	a0 93 1d 02 	sts	0x021D, r26
 9f6:	b0 93 1e 02 	sts	0x021E, r27
	}
	
	/* Tasten entprellen */
	if(count36kHz==0x37||count36kHz==0x7E||count36kHz==0xBD||count36kHz==0xFF)
 9fa:	80 91 1a 02 	lds	r24, 0x021A
 9fe:	87 33       	cpi	r24, 0x37	; 55
 a00:	61 f0       	breq	.+24     	; 0xa1a <__vector_11+0x84>
 a02:	80 91 1a 02 	lds	r24, 0x021A
 a06:	8e 37       	cpi	r24, 0x7E	; 126
 a08:	41 f0       	breq	.+16     	; 0xa1a <__vector_11+0x84>
 a0a:	80 91 1a 02 	lds	r24, 0x021A
 a0e:	8d 3b       	cpi	r24, 0xBD	; 189
 a10:	21 f0       	breq	.+8      	; 0xa1a <__vector_11+0x84>
 a12:	80 91 1a 02 	lds	r24, 0x021A
 a16:	8f 3f       	cpi	r24, 0xFF	; 255
 a18:	11 f4       	brne	.+4      	; 0xa1e <__vector_11+0x88>
		tasten();
 a1a:	0e 94 31 05 	call	0xa62	; 0xa62 <tasten>
 a1e:	ff 91       	pop	r31
 a20:	ef 91       	pop	r30
 a22:	bf 91       	pop	r27
 a24:	af 91       	pop	r26
 a26:	9f 91       	pop	r25
 a28:	8f 91       	pop	r24
 a2a:	7f 91       	pop	r23
 a2c:	6f 91       	pop	r22
 a2e:	5f 91       	pop	r21
 a30:	4f 91       	pop	r20
 a32:	3f 91       	pop	r19
 a34:	2f 91       	pop	r18
 a36:	0f 90       	pop	r0
 a38:	0f be       	out	0x3f, r0	; 63
 a3a:	0f 90       	pop	r0
 a3c:	1f 90       	pop	r1
 a3e:	18 95       	reti

00000a40 <msleep>:
 a40:	bc 01       	movw	r22, r24
 a42:	40 e0       	ldi	r20, 0x00	; 0
 a44:	50 e0       	ldi	r21, 0x00	; 0
 a46:	09 c0       	rjmp	.+18     	; 0xa5a <msleep+0x1a>
 a48:	20 91 1a 02 	lds	r18, 0x021A
 a4c:	2c 5d       	subi	r18, 0xDC	; 220
 a4e:	80 91 1a 02 	lds	r24, 0x021A
 a52:	82 17       	cp	r24, r18
 a54:	e1 f7       	brne	.-8      	; 0xa4e <msleep+0xe>
 a56:	4f 5f       	subi	r20, 0xFF	; 255
 a58:	5f 4f       	sbci	r21, 0xFF	; 255
 a5a:	46 17       	cp	r20, r22
 a5c:	57 07       	cpc	r21, r23
 a5e:	a4 f3       	brlt	.-24     	; 0xa48 <msleep+0x8>
 a60:	08 95       	ret

00000a62 <tasten>:
  \return
  nichts
*****************************************************************************/
void tasten( void )
{
 a62:	20 91 24 02 	lds	r18, 0x0224
 a66:	80 b1       	in	r24, 0x00	; 0
 a68:	80 95       	com	r24
 a6a:	28 27       	eor	r18, r24
  static char ct0, ct1, rpt;
  char i;

  i = key_state ^ ~KEY_INPUT;	// key changed ?
  ct0 = ~( ct0 & i );			// reset or count ct0
 a6c:	90 91 19 02 	lds	r25, 0x0219
 a70:	92 23       	and	r25, r18
 a72:	90 95       	com	r25
 a74:	90 93 19 02 	sts	0x0219, r25
  ct1 = (ct0 ^ ct1) & i;		// reset or count ct1
 a78:	80 91 18 02 	lds	r24, 0x0218
 a7c:	89 27       	eor	r24, r25
 a7e:	82 23       	and	r24, r18
 a80:	80 93 18 02 	sts	0x0218, r24
  i &= ct0 & ct1;				// count until roll over 
 a84:	92 23       	and	r25, r18
 a86:	98 23       	and	r25, r24
  key_state ^= i;				// then toggle debounced state
 a88:	80 91 24 02 	lds	r24, 0x0224
 a8c:	89 27       	eor	r24, r25
 a8e:	80 93 24 02 	sts	0x0224, r24
  key_press |= key_state & i;	// 0->1: key pressing detect
 a92:	20 91 23 02 	lds	r18, 0x0223
 a96:	80 91 24 02 	lds	r24, 0x0224
 a9a:	89 23       	and	r24, r25
 a9c:	28 2b       	or	r18, r24
 a9e:	20 93 23 02 	sts	0x0223, r18

  if( (key_state & REPEAT_MASK) == 0 )	// check repeat function
 aa2:	80 91 24 02 	lds	r24, 0x0224
 aa6:	86 70       	andi	r24, 0x06	; 6
 aa8:	21 f4       	brne	.+8      	; 0xab2 <tasten+0x50>
    rpt = REPEAT_START;			// start delay
  if( --rpt == 0 ){
 aaa:	8c e7       	ldi	r24, 0x7C	; 124
 aac:	80 93 17 02 	sts	0x0217, r24
 ab0:	08 95       	ret
 ab2:	80 91 17 02 	lds	r24, 0x0217
 ab6:	81 50       	subi	r24, 0x01	; 1
 ab8:	80 93 17 02 	sts	0x0217, r24
 abc:	88 23       	and	r24, r24
 abe:	59 f4       	brne	.+22     	; 0xad6 <tasten+0x74>
    rpt = REPEAT_NEXT;			// repeat delay
 ac0:	89 e1       	ldi	r24, 0x19	; 25
 ac2:	80 93 17 02 	sts	0x0217, r24
    key_rpt |= key_state & REPEAT_MASK;
 ac6:	90 91 22 02 	lds	r25, 0x0222
 aca:	80 91 24 02 	lds	r24, 0x0224
 ace:	86 70       	andi	r24, 0x06	; 6
 ad0:	98 2b       	or	r25, r24
 ad2:	90 93 22 02 	sts	0x0222, r25
 ad6:	08 95       	ret

00000ad8 <get_key_press>:
  }
}


/****************************************************************************/
/*!
  \brief	Überprüft, ob eine Taste betätigt worden ist.\n
			Jede gedrückte Taste wird nur einmal gemeldet.
  
  \param
  key_mask	Maske der zu Überprüfenden Tasten.

  \return
  Wurde die Makierte Taste betätigt steht an entsprechender Stelle 
			eine 1.
*****************************************************************************/
char get_key_press( char key_mask )
{
 ad8:	2f b7       	in	r18, 0x3f	; 63
  uint8_t tmp_sreg;
  tmp_sreg = SREG;
  cli();
 ada:	f8 94       	cli
  key_mask &= key_press;                        // read key(s)
 adc:	90 91 23 02 	lds	r25, 0x0223
 ae0:	89 23       	and	r24, r25
  key_press ^= key_mask;                        // clear key(s)
 ae2:	90 91 23 02 	lds	r25, 0x0223
 ae6:	98 27       	eor	r25, r24
 ae8:	90 93 23 02 	sts	0x0223, r25
  SREG = tmp_sreg;
 aec:	2f bf       	out	0x3f, r18	; 63
  
  return key_mask;
}
 aee:	99 27       	eor	r25, r25
 af0:	08 95       	ret

00000af2 <get_key_rpt>:


/****************************************************************************/
/*!
  \brief	Überprüft, ob eine Taste lang genug betätigt worden ist, daß die
			tastenwiederholungs Funktion eintritt. Nach einer kleinen 
			Verzögerung wird die gedrückte Taste regelmässig als erneut 
			betätigt Makiert.
			Diese simuliert dem Benutzer ein wiederholendes drücken und 
			loslassen der Taste.
  
  \param
  key_mask	Maske der zu Überprüfenden Tasten.

  \return
  Wurde die Makierte Taste  lange betätigt steht an entsprechender Stelle 
			eine 1.
*****************************************************************************/
char get_key_rpt( char key_mask )
{
 af2:	2f b7       	in	r18, 0x3f	; 63
  uint8_t tmp_sreg;
  tmp_sreg = SREG;
  cli();
 af4:	f8 94       	cli
  key_mask &= key_rpt;                        	// read key(s)
 af6:	90 91 22 02 	lds	r25, 0x0222
 afa:	89 23       	and	r24, r25
  key_rpt ^= key_mask;                        	// clear key(s)
 afc:	90 91 22 02 	lds	r25, 0x0222
 b00:	98 27       	eor	r25, r24
 b02:	90 93 22 02 	sts	0x0222, r25
  SREG = tmp_sreg;
 b06:	2f bf       	out	0x3f, r18	; 63
  return key_mask;
}
 b08:	99 27       	eor	r25, r25
 b0a:	08 95       	ret

00000b0c <strcpy>:
 b0c:	fb 01       	movw	r30, r22
 b0e:	dc 01       	movw	r26, r24
 b10:	01 90       	ld	r0, Z+
 b12:	0d 92       	st	X+, r0
 b14:	00 20       	and	r0, r0
 b16:	e1 f7       	brne	.-8      	; 0xb10 <strcpy+0x4>
 b18:	08 95       	ret

00000b1a <__udivmodsi4>:
 b1a:	a1 e2       	ldi	r26, 0x21	; 33
 b1c:	1a 2e       	mov	r1, r26
 b1e:	aa 1b       	sub	r26, r26
 b20:	bb 1b       	sub	r27, r27
 b22:	fd 01       	movw	r30, r26
 b24:	0d c0       	rjmp	.+26     	; 0xb40 <__udivmodsi4_ep>

00000b26 <__udivmodsi4_loop>:
 b26:	aa 1f       	adc	r26, r26
 b28:	bb 1f       	adc	r27, r27
 b2a:	ee 1f       	adc	r30, r30
 b2c:	ff 1f       	adc	r31, r31
 b2e:	a2 17       	cp	r26, r18
 b30:	b3 07       	cpc	r27, r19
 b32:	e4 07       	cpc	r30, r20
 b34:	f5 07       	cpc	r31, r21
 b36:	20 f0       	brcs	.+8      	; 0xb40 <__udivmodsi4_ep>
 b38:	a2 1b       	sub	r26, r18
 b3a:	b3 0b       	sbc	r27, r19
 b3c:	e4 0b       	sbc	r30, r20
 b3e:	f5 0b       	sbc	r31, r21

00000b40 <__udivmodsi4_ep>:
 b40:	66 1f       	adc	r22, r22
 b42:	77 1f       	adc	r23, r23
 b44:	88 1f       	adc	r24, r24
 b46:	99 1f       	adc	r25, r25
 b48:	1a 94       	dec	r1
 b4a:	69 f7       	brne	.-38     	; 0xb26 <__udivmodsi4_loop>
 b4c:	60 95       	com	r22
 b4e:	70 95       	com	r23
 b50:	80 95       	com	r24
 b52:	90 95       	com	r25
 b54:	9b 01       	movw	r18, r22
 b56:	ac 01       	movw	r20, r24
 b58:	bd 01       	movw	r22, r26
 b5a:	cf 01       	movw	r24, r30
 b5c:	08 95       	ret

00000b5e <_exit>:
 b5e:	ff cf       	rjmp	.-2      	; 0xb5e <_exit>
