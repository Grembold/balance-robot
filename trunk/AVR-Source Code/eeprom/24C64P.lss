
24C64P.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000682  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000068  00800060  00000682  00000716  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  008000c8  000006ea  0000077e  2**0
                  ALLOC
  3 .noinit       00000000  008000c8  008000c8  0000077e  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  0000077e  2**0
                  CONTENTS
  5 .stab         0000036c  00000000  00000000  00000780  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000084  00000000  00000000  00000aec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 0000003c  00000000  00000000  00000b70  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000152  00000000  00000000  00000bac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00000716  00000000  00000000  00000cfe  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000001e5  00000000  00000000  00001414  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00000476  00000000  00000000  000015f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000015  00000000  00000000  00001a6f  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54 <__ctors_end>
   4:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
   8:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
   c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  10:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  14:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  18:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  1c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  20:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  24:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  28:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  2c:	0c 94 d2 02 	jmp	0x5a4 <__vector_11>
  30:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  34:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  38:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  3c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  40:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  44:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  48:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  4c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  50:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e8       	ldi	r30, 0x82	; 130
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a8 3c       	cpi	r26, 0xC8	; 200
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a8 ec       	ldi	r26, 0xC8	; 200
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a8 3c       	cpi	r26, 0xC8	; 200
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0c 94 47 00 	jmp	0x8e <main>

0000008a <__bad_interrupt>:
  8a:	0c 94 00 00 	jmp	0x0 <__vectors>

0000008e <main>:
#define __need_size_t


int main(void)
{
  8e:	cd e5       	ldi	r28, 0x5D	; 93
  90:	d4 e0       	ldi	r29, 0x04	; 4
  92:	de bf       	out	0x3e, r29	; 62
  94:	cd bf       	out	0x3d, r28	; 61
	uint8_t status;
	uint8_t data;
	

	status = eeprom_init();
  96:	0e 94 67 00 	call	0xce <eeprom_init>
  9a:	89 83       	std	Y+1, r24	; 0x01
	if(status)
  9c:	89 81       	ldd	r24, Y+1	; 0x01
  9e:	88 23       	and	r24, r24
  a0:	21 f0       	breq	.+8      	; 0xaa <main+0x1c>
		uart_puts("lalalal");
  a2:	80 e6       	ldi	r24, 0x60	; 96
  a4:	90 e0       	ldi	r25, 0x00	; 0
  a6:	0e 94 85 02 	call	0x50a <uart_puts>
	eeprom_write_byte(0x0005, 47);
  aa:	6f e2       	ldi	r22, 0x2F	; 47
  ac:	85 e0       	ldi	r24, 0x05	; 5
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	0e 94 06 01 	call	0x20c <eeprom_write_byte>
	data = eeprom_read_byte(0x0005);
  b4:	85 e0       	ldi	r24, 0x05	; 5
  b6:	90 e0       	ldi	r25, 0x00	; 0
  b8:	0e 94 9a 00 	call	0x134 <eeprom_read_byte>
  bc:	8a 83       	std	Y+2, r24	; 0x02
	uart_puti(&data);
  be:	ce 01       	movw	r24, r28
  c0:	02 96       	adiw	r24, 0x02	; 2
  c2:	0e 94 ad 02 	call	0x55a <uart_puti>
}
  c6:	80 e0       	ldi	r24, 0x00	; 0
  c8:	90 e0       	ldi	r25, 0x00	; 0
  ca:	0c 94 40 03 	jmp	0x680 <_exit>

000000ce <eeprom_init>:


uint8_t eeprom_init()
{
  ce:	cf 93       	push	r28
  d0:	df 93       	push	r29
  d2:	cd b7       	in	r28, 0x3d	; 61
  d4:	de b7       	in	r29, 0x3e	; 62
  d6:	23 97       	sbiw	r28, 0x03	; 3
  d8:	0f b6       	in	r0, 0x3f	; 63
  da:	f8 94       	cli
  dc:	de bf       	out	0x3e, r29	; 62
  de:	0f be       	out	0x3f, r0	; 63
  e0:	cd bf       	out	0x3d, r28	; 61
	i2c_init(); 		// init des I2C interfaces
  e2:	0e 94 31 01 	call	0x262 <i2c_init>
#if USE_UART
	uart_init();
  e6:	0e 94 50 02 	call	0x4a0 <uart_init>
#endif

	uint8_t ret;		//returnwert
	/* write 0x75 to eeprom address 0x05 (Byte Write) */
    ret = i2c_start(Dev24C64+I2C_READ);       // set device address and write mode
  ea:	81 ea       	ldi	r24, 0xA1	; 161
  ec:	0e 94 3d 01 	call	0x27a <i2c_start>
  f0:	89 83       	std	Y+1, r24	; 0x01
    if ( ret ) {
  f2:	89 81       	ldd	r24, Y+1	; 0x01
  f4:	88 23       	and	r24, r24
  f6:	59 f0       	breq	.+22     	; 0x10e <eeprom_init+0x40>
        // Arbittierung fehlgeschlagen, vileicht devicenummer falsch 
        i2c_stop();
  f8:	0e 94 ea 01 	call	0x3d4 <i2c_stop>
#ifdef USE_UART
		uart_puts("EEPROM initialisiert ... FEHLER!");   	// Fehlermeldung EEprom konnte nicht gefunden werden
  fc:	88 e6       	ldi	r24, 0x68	; 104
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	0e 94 85 02 	call	0x50a <uart_puts>
#endif
		return 1;
 104:	81 e0       	ldi	r24, 0x01	; 1
 106:	90 e0       	ldi	r25, 0x00	; 0
 108:	9b 83       	std	Y+3, r25	; 0x03
 10a:	8a 83       	std	Y+2, r24	; 0x02
 10c:	08 c0       	rjmp	.+16     	; 0x11e <eeprom_init+0x50>
    }else {
#ifdef USE_UART
		uart_puts("EEPROM initialisiert ... OK"); 				//alles geklappt
 10e:	89 e8       	ldi	r24, 0x89	; 137
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	0e 94 85 02 	call	0x50a <uart_puts>
#endif
        i2c_stop();
 116:	0e 94 ea 01 	call	0x3d4 <i2c_stop>
		return 0;
 11a:	1b 82       	std	Y+3, r1	; 0x03
 11c:	1a 82       	std	Y+2, r1	; 0x02
	}

	
	return 1;		// bis hier sollte es nicht kommen
}
 11e:	8a 81       	ldd	r24, Y+2	; 0x02
 120:	9b 81       	ldd	r25, Y+3	; 0x03
 122:	23 96       	adiw	r28, 0x03	; 3
 124:	0f b6       	in	r0, 0x3f	; 63
 126:	f8 94       	cli
 128:	de bf       	out	0x3e, r29	; 62
 12a:	0f be       	out	0x3f, r0	; 63
 12c:	cd bf       	out	0x3d, r28	; 61
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	08 95       	ret

00000134 <eeprom_read_byte>:

/** liest ein Byte aus dem externen EEPROM **/
uint8_t eeprom_read_byte (const uint16_t addr) 
{
 134:	cf 93       	push	r28
 136:	df 93       	push	r29
 138:	cd b7       	in	r28, 0x3d	; 61
 13a:	de b7       	in	r29, 0x3e	; 62
 13c:	25 97       	sbiw	r28, 0x05	; 5
 13e:	0f b6       	in	r0, 0x3f	; 63
 140:	f8 94       	cli
 142:	de bf       	out	0x3e, r29	; 62
 144:	0f be       	out	0x3f, r0	; 63
 146:	cd bf       	out	0x3d, r28	; 61
 148:	9a 83       	std	Y+2, r25	; 0x02
 14a:	89 83       	std	Y+1, r24	; 0x01
	uint8_t addrH = addr;
 14c:	89 81       	ldd	r24, Y+1	; 0x01
 14e:	8b 83       	std	Y+3, r24	; 0x03
	uint8_t addrL = addr>>8;
 150:	89 81       	ldd	r24, Y+1	; 0x01
 152:	9a 81       	ldd	r25, Y+2	; 0x02
 154:	89 2f       	mov	r24, r25
 156:	99 27       	eor	r25, r25
 158:	8c 83       	std	Y+4, r24	; 0x04
	uint8_t result;
	
    /* wait until the device is no longer busy from the previous operation 
		write adress and return Byte */
	i2c_start_wait(Dev24C64+I2C_WRITE);     // set device address and write mode
 15a:	80 ea       	ldi	r24, 0xA0	; 160
 15c:	0e 94 88 01 	call	0x310 <i2c_start_wait>
	i2c_write(addrH);						// set address
 160:	8b 81       	ldd	r24, Y+3	; 0x03
 162:	0e 94 fc 01 	call	0x3f8 <i2c_write>
	i2c_write(addrL);                       
 166:	8c 81       	ldd	r24, Y+4	; 0x04
 168:	0e 94 fc 01 	call	0x3f8 <i2c_write>
    i2c_rep_start(Dev24C64+I2C_READ);       // set device address and read mode
 16c:	81 ea       	ldi	r24, 0xA1	; 161
 16e:	0e 94 d2 01 	call	0x3a4 <i2c_rep_start>
    result = i2c_readNak();                 // read one byte
 172:	0e 94 3e 02 	call	0x47c <i2c_readNak>
 176:	8d 83       	std	Y+5, r24	; 0x05
    i2c_stop();
 178:	0e 94 ea 01 	call	0x3d4 <i2c_stop>
	return result;
 17c:	8d 81       	ldd	r24, Y+5	; 0x05
 17e:	99 27       	eor	r25, r25
 180:	25 96       	adiw	r28, 0x05	; 5
 182:	0f b6       	in	r0, 0x3f	; 63
 184:	f8 94       	cli
 186:	de bf       	out	0x3e, r29	; 62
 188:	0f be       	out	0x3f, r0	; 63
 18a:	cd bf       	out	0x3d, r28	; 61
 18c:	df 91       	pop	r29
 18e:	cf 91       	pop	r28
 190:	08 95       	ret

00000192 <eeprom_read_word>:
}


uint16_t eeprom_read_word (uint16_t addr)
{
 192:	cf 93       	push	r28
 194:	df 93       	push	r29
 196:	cd b7       	in	r28, 0x3d	; 61
 198:	de b7       	in	r29, 0x3e	; 62
 19a:	26 97       	sbiw	r28, 0x06	; 6
 19c:	0f b6       	in	r0, 0x3f	; 63
 19e:	f8 94       	cli
 1a0:	de bf       	out	0x3e, r29	; 62
 1a2:	0f be       	out	0x3f, r0	; 63
 1a4:	cd bf       	out	0x3d, r28	; 61
 1a6:	9a 83       	std	Y+2, r25	; 0x02
 1a8:	89 83       	std	Y+1, r24	; 0x01
	uint8_t addrH = addr;
 1aa:	89 81       	ldd	r24, Y+1	; 0x01
 1ac:	8b 83       	std	Y+3, r24	; 0x03
	uint8_t addrL = addr>>8;
 1ae:	89 81       	ldd	r24, Y+1	; 0x01
 1b0:	9a 81       	ldd	r25, Y+2	; 0x02
 1b2:	89 2f       	mov	r24, r25
 1b4:	99 27       	eor	r25, r25
 1b6:	8c 83       	std	Y+4, r24	; 0x04
	uint16_t result;
  
  /* wait until the device is no longer busy from the previous operation 
	write adress and return Byte*/
	i2c_start_wait(Dev24C64+I2C_WRITE);     // set device address and write mode
 1b8:	80 ea       	ldi	r24, 0xA0	; 160
 1ba:	0e 94 88 01 	call	0x310 <i2c_start_wait>
	i2c_write(addrH);
 1be:	8b 81       	ldd	r24, Y+3	; 0x03
 1c0:	0e 94 fc 01 	call	0x3f8 <i2c_write>
	i2c_write(addrL);                        // write address = 5
 1c4:	8c 81       	ldd	r24, Y+4	; 0x04
 1c6:	0e 94 fc 01 	call	0x3f8 <i2c_write>
    i2c_rep_start(Dev24C64+I2C_READ);       // set device address and read mode
 1ca:	81 ea       	ldi	r24, 0xA1	; 161
 1cc:	0e 94 d2 01 	call	0x3a4 <i2c_rep_start>
	result = (i2c_readAck()<<8);
 1d0:	0e 94 2c 02 	call	0x458 <i2c_readAck>
 1d4:	99 27       	eor	r25, r25
 1d6:	98 2f       	mov	r25, r24
 1d8:	88 27       	eor	r24, r24
 1da:	9e 83       	std	Y+6, r25	; 0x06
 1dc:	8d 83       	std	Y+5, r24	; 0x05
    result |= i2c_readNak();                    // read one byte
 1de:	0e 94 3e 02 	call	0x47c <i2c_readNak>
 1e2:	28 2f       	mov	r18, r24
 1e4:	33 27       	eor	r19, r19
 1e6:	8d 81       	ldd	r24, Y+5	; 0x05
 1e8:	9e 81       	ldd	r25, Y+6	; 0x06
 1ea:	82 2b       	or	r24, r18
 1ec:	93 2b       	or	r25, r19
 1ee:	9e 83       	std	Y+6, r25	; 0x06
 1f0:	8d 83       	std	Y+5, r24	; 0x05
    i2c_stop();
 1f2:	0e 94 ea 01 	call	0x3d4 <i2c_stop>

	return result;
 1f6:	8d 81       	ldd	r24, Y+5	; 0x05
 1f8:	9e 81       	ldd	r25, Y+6	; 0x06
 1fa:	26 96       	adiw	r28, 0x06	; 6
 1fc:	0f b6       	in	r0, 0x3f	; 63
 1fe:	f8 94       	cli
 200:	de bf       	out	0x3e, r29	; 62
 202:	0f be       	out	0x3f, r0	; 63
 204:	cd bf       	out	0x3d, r28	; 61
 206:	df 91       	pop	r29
 208:	cf 91       	pop	r28
 20a:	08 95       	ret

0000020c <eeprom_write_byte>:
}

/** lschreibt ein Byte in dem externen EEPROM **/
void eeprom_write_byte (uint16_t addr, uint8_t data) 
{
 20c:	cf 93       	push	r28
 20e:	df 93       	push	r29
 210:	cd b7       	in	r28, 0x3d	; 61
 212:	de b7       	in	r29, 0x3e	; 62
 214:	25 97       	sbiw	r28, 0x05	; 5
 216:	0f b6       	in	r0, 0x3f	; 63
 218:	f8 94       	cli
 21a:	de bf       	out	0x3e, r29	; 62
 21c:	0f be       	out	0x3f, r0	; 63
 21e:	cd bf       	out	0x3d, r28	; 61
 220:	9a 83       	std	Y+2, r25	; 0x02
 222:	89 83       	std	Y+1, r24	; 0x01
 224:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t addrH = addr;
 226:	89 81       	ldd	r24, Y+1	; 0x01
 228:	8c 83       	std	Y+4, r24	; 0x04
	uint8_t addrL = addr>>8;
 22a:	89 81       	ldd	r24, Y+1	; 0x01
 22c:	9a 81       	ldd	r25, Y+2	; 0x02
 22e:	89 2f       	mov	r24, r25
 230:	99 27       	eor	r25, r25
 232:	8d 83       	std	Y+5, r24	; 0x05
	
    /* wait until the device is no longer busy from the previous operation 
		write adress and return Byte */
	i2c_start_wait(Dev24C64+I2C_WRITE);     // Ruft den Speicher im schreibmodus auf
 234:	80 ea       	ldi	r24, 0xA0	; 160
 236:	0e 94 88 01 	call	0x310 <i2c_start_wait>
	i2c_write(addrH);			// setzt die Speicher addresse
 23a:	8c 81       	ldd	r24, Y+4	; 0x04
 23c:	0e 94 fc 01 	call	0x3f8 <i2c_write>
	i2c_write(addrL);
 240:	8d 81       	ldd	r24, Y+5	; 0x05
 242:	0e 94 fc 01 	call	0x3f8 <i2c_write>
	i2c_write(data);			//schreibt das Byte in den Speicher
 246:	8b 81       	ldd	r24, Y+3	; 0x03
 248:	0e 94 fc 01 	call	0x3f8 <i2c_write>
    i2c_stop();
 24c:	0e 94 ea 01 	call	0x3d4 <i2c_stop>
 250:	25 96       	adiw	r28, 0x05	; 5
 252:	0f b6       	in	r0, 0x3f	; 63
 254:	f8 94       	cli
 256:	de bf       	out	0x3e, r29	; 62
 258:	0f be       	out	0x3f, r0	; 63
 25a:	cd bf       	out	0x3d, r28	; 61
 25c:	df 91       	pop	r29
 25e:	cf 91       	pop	r28
 260:	08 95       	ret

00000262 <i2c_init>:
/*************************************************************************
 Initialization of the I2C bus interface. Need to be called only once
*************************************************************************/
void i2c_init(void)
{
 262:	cf 93       	push	r28
 264:	df 93       	push	r29
 266:	cd b7       	in	r28, 0x3d	; 61
 268:	de b7       	in	r29, 0x3e	; 62
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  
  TWSR = 0;                         /* no prescaler */
 26a:	10 92 21 00 	sts	0x0021, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
 26e:	8f e2       	ldi	r24, 0x2F	; 47
 270:	80 93 20 00 	sts	0x0020, r24
 274:	df 91       	pop	r29
 276:	cf 91       	pop	r28
 278:	08 95       	ret

0000027a <i2c_start>:

}/* i2c_init */


/*************************************************************************	
  Issues a start condition and sends address and transfer direction.
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
 27a:	cf 93       	push	r28
 27c:	df 93       	push	r29
 27e:	cd b7       	in	r28, 0x3d	; 61
 280:	de b7       	in	r29, 0x3e	; 62
 282:	24 97       	sbiw	r28, 0x04	; 4
 284:	0f b6       	in	r0, 0x3f	; 63
 286:	f8 94       	cli
 288:	de bf       	out	0x3e, r29	; 62
 28a:	0f be       	out	0x3f, r0	; 63
 28c:	cd bf       	out	0x3d, r28	; 61
 28e:	89 83       	std	Y+1, r24	; 0x01
    uint8_t   twst;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 290:	84 ea       	ldi	r24, 0xA4	; 164
 292:	80 93 56 00 	sts	0x0056, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 296:	80 91 56 00 	lds	r24, 0x0056
 29a:	88 23       	and	r24, r24
 29c:	0c f0       	brlt	.+2      	; 0x2a0 <i2c_start+0x26>
 29e:	fb cf       	rjmp	.-10     	; 0x296 <i2c_start+0x1c>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
 2a0:	98 ef       	ldi	r25, 0xF8	; 248
 2a2:	80 91 21 00 	lds	r24, 0x0021
 2a6:	89 23       	and	r24, r25
 2a8:	8a 83       	std	Y+2, r24	; 0x02
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 2aa:	8a 81       	ldd	r24, Y+2	; 0x02
 2ac:	88 30       	cpi	r24, 0x08	; 8
 2ae:	41 f0       	breq	.+16     	; 0x2c0 <i2c_start+0x46>
 2b0:	8a 81       	ldd	r24, Y+2	; 0x02
 2b2:	80 31       	cpi	r24, 0x10	; 16
 2b4:	29 f0       	breq	.+10     	; 0x2c0 <i2c_start+0x46>
 2b6:	81 e0       	ldi	r24, 0x01	; 1
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	9c 83       	std	Y+4, r25	; 0x04
 2bc:	8b 83       	std	Y+3, r24	; 0x03
 2be:	1d c0       	rjmp	.+58     	; 0x2fa <i2c_start+0x80>

	// send device address
	TWDR = address;
 2c0:	89 81       	ldd	r24, Y+1	; 0x01
 2c2:	80 93 23 00 	sts	0x0023, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
 2c6:	84 e8       	ldi	r24, 0x84	; 132
 2c8:	80 93 56 00 	sts	0x0056, r24

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
 2cc:	80 91 56 00 	lds	r24, 0x0056
 2d0:	88 23       	and	r24, r24
 2d2:	0c f0       	brlt	.+2      	; 0x2d6 <i2c_start+0x5c>
 2d4:	fb cf       	rjmp	.-10     	; 0x2cc <i2c_start+0x52>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
 2d6:	98 ef       	ldi	r25, 0xF8	; 248
 2d8:	80 91 21 00 	lds	r24, 0x0021
 2dc:	89 23       	and	r24, r25
 2de:	8a 83       	std	Y+2, r24	; 0x02
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 2e0:	8a 81       	ldd	r24, Y+2	; 0x02
 2e2:	88 31       	cpi	r24, 0x18	; 24
 2e4:	41 f0       	breq	.+16     	; 0x2f6 <i2c_start+0x7c>
 2e6:	8a 81       	ldd	r24, Y+2	; 0x02
 2e8:	80 34       	cpi	r24, 0x40	; 64
 2ea:	29 f0       	breq	.+10     	; 0x2f6 <i2c_start+0x7c>
 2ec:	81 e0       	ldi	r24, 0x01	; 1
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	9c 83       	std	Y+4, r25	; 0x04
 2f2:	8b 83       	std	Y+3, r24	; 0x03
 2f4:	02 c0       	rjmp	.+4      	; 0x2fa <i2c_start+0x80>

	return 0;
 2f6:	1c 82       	std	Y+4, r1	; 0x04
 2f8:	1b 82       	std	Y+3, r1	; 0x03

}/* i2c_start */
 2fa:	8b 81       	ldd	r24, Y+3	; 0x03
 2fc:	9c 81       	ldd	r25, Y+4	; 0x04
 2fe:	24 96       	adiw	r28, 0x04	; 4
 300:	0f b6       	in	r0, 0x3f	; 63
 302:	f8 94       	cli
 304:	de bf       	out	0x3e, r29	; 62
 306:	0f be       	out	0x3f, r0	; 63
 308:	cd bf       	out	0x3d, r28	; 61
 30a:	df 91       	pop	r29
 30c:	cf 91       	pop	r28
 30e:	08 95       	ret

00000310 <i2c_start_wait>:


/*************************************************************************
 Issues a start condition and sends address and transfer direction.
 If device is busy, use ack polling to wait until device is ready
 
 Input:   address and transfer direction of I2C device
*************************************************************************/
void i2c_start_wait(unsigned char address)
{
 310:	cf 93       	push	r28
 312:	df 93       	push	r29
 314:	cd b7       	in	r28, 0x3d	; 61
 316:	de b7       	in	r29, 0x3e	; 62
 318:	22 97       	sbiw	r28, 0x02	; 2
 31a:	0f b6       	in	r0, 0x3f	; 63
 31c:	f8 94       	cli
 31e:	de bf       	out	0x3e, r29	; 62
 320:	0f be       	out	0x3f, r0	; 63
 322:	cd bf       	out	0x3d, r28	; 61
 324:	89 83       	std	Y+1, r24	; 0x01
    uint8_t   twst;


    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 326:	84 ea       	ldi	r24, 0xA4	; 164
 328:	80 93 56 00 	sts	0x0056, r24
    
    	// wait until transmission completed
    	while(!(TWCR & (1<<TWINT)));
 32c:	80 91 56 00 	lds	r24, 0x0056
 330:	88 23       	and	r24, r24
 332:	0c f0       	brlt	.+2      	; 0x336 <i2c_start_wait+0x26>
 334:	fb cf       	rjmp	.-10     	; 0x32c <i2c_start_wait+0x1c>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
 336:	98 ef       	ldi	r25, 0xF8	; 248
 338:	80 91 21 00 	lds	r24, 0x0021
 33c:	89 23       	and	r24, r25
 33e:	8a 83       	std	Y+2, r24	; 0x02
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 340:	8a 81       	ldd	r24, Y+2	; 0x02
 342:	88 30       	cpi	r24, 0x08	; 8
 344:	21 f0       	breq	.+8      	; 0x34e <i2c_start_wait+0x3e>
 346:	8a 81       	ldd	r24, Y+2	; 0x02
 348:	80 31       	cpi	r24, 0x10	; 16
 34a:	09 f0       	breq	.+2      	; 0x34e <i2c_start_wait+0x3e>
 34c:	ec cf       	rjmp	.-40     	; 0x326 <i2c_start_wait+0x16>
    
    	// send device address
    	TWDR = address;
 34e:	89 81       	ldd	r24, Y+1	; 0x01
 350:	80 93 23 00 	sts	0x0023, r24
    	TWCR = (1<<TWINT) | (1<<TWEN);
 354:	84 e8       	ldi	r24, 0x84	; 132
 356:	80 93 56 00 	sts	0x0056, r24
    
    	// wail until transmission completed
    	while(!(TWCR & (1<<TWINT)));
 35a:	80 91 56 00 	lds	r24, 0x0056
 35e:	88 23       	and	r24, r24
 360:	0c f0       	brlt	.+2      	; 0x364 <i2c_start_wait+0x54>
 362:	fb cf       	rjmp	.-10     	; 0x35a <i2c_start_wait+0x4a>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
 364:	98 ef       	ldi	r25, 0xF8	; 248
 366:	80 91 21 00 	lds	r24, 0x0021
 36a:	89 23       	and	r24, r25
 36c:	8a 83       	std	Y+2, r24	; 0x02
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 36e:	8a 81       	ldd	r24, Y+2	; 0x02
 370:	80 32       	cpi	r24, 0x20	; 32
 372:	21 f0       	breq	.+8      	; 0x37c <i2c_start_wait+0x6c>
 374:	8a 81       	ldd	r24, Y+2	; 0x02
 376:	88 35       	cpi	r24, 0x58	; 88
 378:	09 f0       	breq	.+2      	; 0x37c <i2c_start_wait+0x6c>
 37a:	0b c0       	rjmp	.+22     	; 0x392 <i2c_start_wait+0x82>
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 37c:	84 e9       	ldi	r24, 0x94	; 148
 37e:	80 93 56 00 	sts	0x0056, r24
	        
	        // wait until stop condition is executed and bus released
	        while(TWCR & (1<<TWSTO));
 382:	80 91 56 00 	lds	r24, 0x0056
 386:	99 27       	eor	r25, r25
 388:	80 71       	andi	r24, 0x10	; 16
 38a:	90 70       	andi	r25, 0x00	; 0
 38c:	00 97       	sbiw	r24, 0x00	; 0
 38e:	59 f2       	breq	.-106    	; 0x326 <i2c_start_wait+0x16>
 390:	f8 cf       	rjmp	.-16     	; 0x382 <i2c_start_wait+0x72>
 392:	22 96       	adiw	r28, 0x02	; 2
 394:	0f b6       	in	r0, 0x3f	; 63
 396:	f8 94       	cli
 398:	de bf       	out	0x3e, r29	; 62
 39a:	0f be       	out	0x3f, r0	; 63
 39c:	cd bf       	out	0x3d, r28	; 61
 39e:	df 91       	pop	r29
 3a0:	cf 91       	pop	r28
 3a2:	08 95       	ret

000003a4 <i2c_rep_start>:
	        
    	    continue;
    	}
    	//if( twst != TW_MT_SLA_ACK) return 1;
    	break;
     }

}/* i2c_start_wait */


/*************************************************************************
 Issues a repeated start condition and sends address and transfer direction 

 Input:   address and transfer direction of I2C device
 
 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
 3a4:	cf 93       	push	r28
 3a6:	df 93       	push	r29
 3a8:	cd b7       	in	r28, 0x3d	; 61
 3aa:	de b7       	in	r29, 0x3e	; 62
 3ac:	21 97       	sbiw	r28, 0x01	; 1
 3ae:	0f b6       	in	r0, 0x3f	; 63
 3b0:	f8 94       	cli
 3b2:	de bf       	out	0x3e, r29	; 62
 3b4:	0f be       	out	0x3f, r0	; 63
 3b6:	cd bf       	out	0x3d, r28	; 61
 3b8:	89 83       	std	Y+1, r24	; 0x01
    return i2c_start( address );
 3ba:	89 81       	ldd	r24, Y+1	; 0x01
 3bc:	0e 94 3d 01 	call	0x27a <i2c_start>
 3c0:	99 27       	eor	r25, r25
 3c2:	21 96       	adiw	r28, 0x01	; 1
 3c4:	0f b6       	in	r0, 0x3f	; 63
 3c6:	f8 94       	cli
 3c8:	de bf       	out	0x3e, r29	; 62
 3ca:	0f be       	out	0x3f, r0	; 63
 3cc:	cd bf       	out	0x3d, r28	; 61
 3ce:	df 91       	pop	r29
 3d0:	cf 91       	pop	r28
 3d2:	08 95       	ret

000003d4 <i2c_stop>:

}/* i2c_rep_start */


/*************************************************************************
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
 3d4:	cf 93       	push	r28
 3d6:	df 93       	push	r29
 3d8:	cd b7       	in	r28, 0x3d	; 61
 3da:	de b7       	in	r29, 0x3e	; 62
    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 3dc:	84 e9       	ldi	r24, 0x94	; 148
 3de:	80 93 56 00 	sts	0x0056, r24
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
 3e2:	80 91 56 00 	lds	r24, 0x0056
 3e6:	99 27       	eor	r25, r25
 3e8:	80 71       	andi	r24, 0x10	; 16
 3ea:	90 70       	andi	r25, 0x00	; 0
 3ec:	00 97       	sbiw	r24, 0x00	; 0
 3ee:	09 f0       	breq	.+2      	; 0x3f2 <i2c_stop+0x1e>
 3f0:	f8 cf       	rjmp	.-16     	; 0x3e2 <i2c_stop+0xe>
 3f2:	df 91       	pop	r29
 3f4:	cf 91       	pop	r28
 3f6:	08 95       	ret

000003f8 <i2c_write>:

}/* i2c_stop */


/*************************************************************************
  Send one byte to I2C device
  
  Input:    byte to be transfered
  Return:   0 write successful 
            1 write failed
*************************************************************************/
unsigned char i2c_write( unsigned char data )
{	
 3f8:	cf 93       	push	r28
 3fa:	df 93       	push	r29
 3fc:	cd b7       	in	r28, 0x3d	; 61
 3fe:	de b7       	in	r29, 0x3e	; 62
 400:	24 97       	sbiw	r28, 0x04	; 4
 402:	0f b6       	in	r0, 0x3f	; 63
 404:	f8 94       	cli
 406:	de bf       	out	0x3e, r29	; 62
 408:	0f be       	out	0x3f, r0	; 63
 40a:	cd bf       	out	0x3d, r28	; 61
 40c:	89 83       	std	Y+1, r24	; 0x01
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
 40e:	89 81       	ldd	r24, Y+1	; 0x01
 410:	80 93 23 00 	sts	0x0023, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
 414:	84 e8       	ldi	r24, 0x84	; 132
 416:	80 93 56 00 	sts	0x0056, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 41a:	80 91 56 00 	lds	r24, 0x0056
 41e:	88 23       	and	r24, r24
 420:	0c f0       	brlt	.+2      	; 0x424 <i2c_write+0x2c>
 422:	fb cf       	rjmp	.-10     	; 0x41a <i2c_write+0x22>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
 424:	98 ef       	ldi	r25, 0xF8	; 248
 426:	80 91 21 00 	lds	r24, 0x0021
 42a:	89 23       	and	r24, r25
 42c:	8a 83       	std	Y+2, r24	; 0x02
	if( twst != TW_MT_DATA_ACK) return 1;
 42e:	8a 81       	ldd	r24, Y+2	; 0x02
 430:	88 32       	cpi	r24, 0x28	; 40
 432:	29 f0       	breq	.+10     	; 0x43e <i2c_write+0x46>
 434:	81 e0       	ldi	r24, 0x01	; 1
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	9c 83       	std	Y+4, r25	; 0x04
 43a:	8b 83       	std	Y+3, r24	; 0x03
 43c:	02 c0       	rjmp	.+4      	; 0x442 <i2c_write+0x4a>
	return 0;
 43e:	1c 82       	std	Y+4, r1	; 0x04
 440:	1b 82       	std	Y+3, r1	; 0x03

}/* i2c_write */
 442:	8b 81       	ldd	r24, Y+3	; 0x03
 444:	9c 81       	ldd	r25, Y+4	; 0x04
 446:	24 96       	adiw	r28, 0x04	; 4
 448:	0f b6       	in	r0, 0x3f	; 63
 44a:	f8 94       	cli
 44c:	de bf       	out	0x3e, r29	; 62
 44e:	0f be       	out	0x3f, r0	; 63
 450:	cd bf       	out	0x3d, r28	; 61
 452:	df 91       	pop	r29
 454:	cf 91       	pop	r28
 456:	08 95       	ret

00000458 <i2c_readAck>:


/*************************************************************************
 Read one byte from the I2C device, request more data from device 
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
 458:	cf 93       	push	r28
 45a:	df 93       	push	r29
 45c:	cd b7       	in	r28, 0x3d	; 61
 45e:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 460:	84 ec       	ldi	r24, 0xC4	; 196
 462:	80 93 56 00 	sts	0x0056, r24
	while(!(TWCR & (1<<TWINT)));    
 466:	80 91 56 00 	lds	r24, 0x0056
 46a:	88 23       	and	r24, r24
 46c:	0c f0       	brlt	.+2      	; 0x470 <__stack+0x11>
 46e:	fb cf       	rjmp	.-10     	; 0x466 <__stack+0x7>

    return TWDR;
 470:	80 91 23 00 	lds	r24, 0x0023
 474:	99 27       	eor	r25, r25
 476:	df 91       	pop	r29
 478:	cf 91       	pop	r28
 47a:	08 95       	ret

0000047c <i2c_readNak>:

}/* i2c_readAck */


/*************************************************************************
 Read one byte from the I2C device, read is followed by a stop condition 
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
 47c:	cf 93       	push	r28
 47e:	df 93       	push	r29
 480:	cd b7       	in	r28, 0x3d	; 61
 482:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWINT) | (1<<TWEN);
 484:	84 e8       	ldi	r24, 0x84	; 132
 486:	80 93 56 00 	sts	0x0056, r24
	while(!(TWCR & (1<<TWINT)));
 48a:	80 91 56 00 	lds	r24, 0x0056
 48e:	88 23       	and	r24, r24
 490:	0c f0       	brlt	.+2      	; 0x494 <i2c_readNak+0x18>
 492:	fb cf       	rjmp	.-10     	; 0x48a <i2c_readNak+0xe>
	
    return TWDR;
 494:	80 91 23 00 	lds	r24, 0x0023
 498:	99 27       	eor	r25, r25
 49a:	df 91       	pop	r29
 49c:	cf 91       	pop	r28
 49e:	08 95       	ret

000004a0 <uart_init>:
#include <stdlib.h>
#include "uart.h"

void uart_init(void)
{
 4a0:	cf 93       	push	r28
 4a2:	df 93       	push	r29
 4a4:	cd b7       	in	r28, 0x3d	; 61
 4a6:	de b7       	in	r29, 0x3e	; 62
	/* Baudrate einstellen ( Normaler Modus ) */
	UBRRH = (unsigned char) (UBRR_BAUD>>8);
 4a8:	10 92 40 00 	sts	0x0040, r1
	UBRRL = (unsigned char) UBRR_BAUD;
 4ac:	85 e0       	ldi	r24, 0x05	; 5
 4ae:	80 93 29 00 	sts	0x0029, r24

	/* Aktivieren des Empfängers, des Senders und des "Daten empfangen"-Interrupts */
	UCSRB = (1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
 4b2:	88 e9       	ldi	r24, 0x98	; 152
 4b4:	80 93 2a 00 	sts	0x002A, r24

	/* Einstellen des Datenformats: 8 Datenbits, 1 Stoppbit */
	UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
 4b8:	86 e8       	ldi	r24, 0x86	; 134
 4ba:	80 93 40 00 	sts	0x0040, r24
	
	uart_puts("\rUart wurde richtig initialisiert");
 4be:	85 ea       	ldi	r24, 0xA5	; 165
 4c0:	90 e0       	ldi	r25, 0x00	; 0
 4c2:	0e 94 85 02 	call	0x50a <uart_puts>
 4c6:	df 91       	pop	r29
 4c8:	cf 91       	pop	r28
 4ca:	08 95       	ret

000004cc <uart_putc>:
}

/** sendet ein einzelnes Zeichen **/
void uart_putc(char c)
{
 4cc:	cf 93       	push	r28
 4ce:	df 93       	push	r29
 4d0:	cd b7       	in	r28, 0x3d	; 61
 4d2:	de b7       	in	r29, 0x3e	; 62
 4d4:	21 97       	sbiw	r28, 0x01	; 1
 4d6:	0f b6       	in	r0, 0x3f	; 63
 4d8:	f8 94       	cli
 4da:	de bf       	out	0x3e, r29	; 62
 4dc:	0f be       	out	0x3f, r0	; 63
 4de:	cd bf       	out	0x3d, r28	; 61
 4e0:	89 83       	std	Y+1, r24	; 0x01
	/* warten bis der Sendepuffer leer ist */
	while ( !( UCSRA & (1<<UDRE)) );
 4e2:	80 91 2b 00 	lds	r24, 0x002B
 4e6:	99 27       	eor	r25, r25
 4e8:	80 72       	andi	r24, 0x20	; 32
 4ea:	90 70       	andi	r25, 0x00	; 0
 4ec:	00 97       	sbiw	r24, 0x00	; 0
 4ee:	09 f4       	brne	.+2      	; 0x4f2 <uart_putc+0x26>
 4f0:	f8 cf       	rjmp	.-16     	; 0x4e2 <uart_putc+0x16>
	
	/* Zeichen senden */
	UDR = c;
 4f2:	89 81       	ldd	r24, Y+1	; 0x01
 4f4:	80 93 2c 00 	sts	0x002C, r24
 4f8:	21 96       	adiw	r28, 0x01	; 1
 4fa:	0f b6       	in	r0, 0x3f	; 63
 4fc:	f8 94       	cli
 4fe:	de bf       	out	0x3e, r29	; 62
 500:	0f be       	out	0x3f, r0	; 63
 502:	cd bf       	out	0x3d, r28	; 61
 504:	df 91       	pop	r29
 506:	cf 91       	pop	r28
 508:	08 95       	ret

0000050a <uart_puts>:
}

/** sendet einen string **/
void uart_puts(char *s)
{
 50a:	cf 93       	push	r28
 50c:	df 93       	push	r29
 50e:	cd b7       	in	r28, 0x3d	; 61
 510:	de b7       	in	r29, 0x3e	; 62
 512:	22 97       	sbiw	r28, 0x02	; 2
 514:	0f b6       	in	r0, 0x3f	; 63
 516:	f8 94       	cli
 518:	de bf       	out	0x3e, r29	; 62
 51a:	0f be       	out	0x3f, r0	; 63
 51c:	cd bf       	out	0x3d, r28	; 61
 51e:	9a 83       	std	Y+2, r25	; 0x02
 520:	89 83       	std	Y+1, r24	; 0x01
	while (*s) // so lange senden, bis das ende des Strings erreicht ist
 522:	e9 81       	ldd	r30, Y+1	; 0x01
 524:	fa 81       	ldd	r31, Y+2	; 0x02
 526:	80 81       	ld	r24, Z
 528:	88 23       	and	r24, r24
 52a:	59 f0       	breq	.+22     	; 0x542 <uart_puts+0x38>
	{
		uart_putc(*s);
 52c:	e9 81       	ldd	r30, Y+1	; 0x01
 52e:	fa 81       	ldd	r31, Y+2	; 0x02
 530:	80 81       	ld	r24, Z
 532:	0e 94 66 02 	call	0x4cc <uart_putc>
		s++;
 536:	89 81       	ldd	r24, Y+1	; 0x01
 538:	9a 81       	ldd	r25, Y+2	; 0x02
 53a:	01 96       	adiw	r24, 0x01	; 1
 53c:	9a 83       	std	Y+2, r25	; 0x02
 53e:	89 83       	std	Y+1, r24	; 0x01
 540:	f0 cf       	rjmp	.-32     	; 0x522 <uart_puts+0x18>
	}
	uart_putc('\r');
 542:	8d e0       	ldi	r24, 0x0D	; 13
 544:	0e 94 66 02 	call	0x4cc <uart_putc>
 548:	22 96       	adiw	r28, 0x02	; 2
 54a:	0f b6       	in	r0, 0x3f	; 63
 54c:	f8 94       	cli
 54e:	de bf       	out	0x3e, r29	; 62
 550:	0f be       	out	0x3f, r0	; 63
 552:	cd bf       	out	0x3d, r28	; 61
 554:	df 91       	pop	r29
 556:	cf 91       	pop	r28
 558:	08 95       	ret

0000055a <uart_puti>:
}

/** sendet einen Integer **/
void uart_puti(uint8_t *i)
{
 55a:	cf 93       	push	r28
 55c:	df 93       	push	r29
 55e:	cd b7       	in	r28, 0x3d	; 61
 560:	de b7       	in	r29, 0x3e	; 62
 562:	27 97       	sbiw	r28, 0x07	; 7
 564:	0f b6       	in	r0, 0x3f	; 63
 566:	f8 94       	cli
 568:	de bf       	out	0x3e, r29	; 62
 56a:	0f be       	out	0x3f, r0	; 63
 56c:	cd bf       	out	0x3d, r28	; 61
 56e:	9a 83       	std	Y+2, r25	; 0x02
 570:	89 83       	std	Y+1, r24	; 0x01
	unsigned char s[5];
	itoa(*i, s,10);
 572:	9e 01       	movw	r18, r28
 574:	2d 5f       	subi	r18, 0xFD	; 253
 576:	3f 4f       	sbci	r19, 0xFF	; 255
 578:	e9 81       	ldd	r30, Y+1	; 0x01
 57a:	fa 81       	ldd	r31, Y+2	; 0x02
 57c:	80 81       	ld	r24, Z
 57e:	99 27       	eor	r25, r25
 580:	4a e0       	ldi	r20, 0x0A	; 10
 582:	50 e0       	ldi	r21, 0x00	; 0
 584:	b9 01       	movw	r22, r18
 586:	0e 94 fb 02 	call	0x5f6 <itoa>
	uart_puts(s);
 58a:	ce 01       	movw	r24, r28
 58c:	03 96       	adiw	r24, 0x03	; 3
 58e:	0e 94 85 02 	call	0x50a <uart_puts>
 592:	27 96       	adiw	r28, 0x07	; 7
 594:	0f b6       	in	r0, 0x3f	; 63
 596:	f8 94       	cli
 598:	de bf       	out	0x3e, r29	; 62
 59a:	0f be       	out	0x3f, r0	; 63
 59c:	cd bf       	out	0x3d, r28	; 61
 59e:	df 91       	pop	r29
 5a0:	cf 91       	pop	r28
 5a2:	08 95       	ret

000005a4 <__vector_11>:
}



/* Interrupt wird ausgelöst sobald neue Daten im USART-Empfangspuffer liegen */
ISR(USART_RXC_vect)
{
 5a4:	1f 92       	push	r1
 5a6:	0f 92       	push	r0
 5a8:	0f b6       	in	r0, 0x3f	; 63
 5aa:	0f 92       	push	r0
 5ac:	11 24       	eor	r1, r1
 5ae:	8f 93       	push	r24
 5b0:	9f 93       	push	r25
 5b2:	cf 93       	push	r28
 5b4:	df 93       	push	r29
 5b6:	cd b7       	in	r28, 0x3d	; 61
 5b8:	de b7       	in	r29, 0x3e	; 62
 5ba:	21 97       	sbiw	r28, 0x01	; 1
 5bc:	de bf       	out	0x3e, r29	; 62
 5be:	cd bf       	out	0x3d, r28	; 61
	 
	unsigned char buffer;

	/* Daten aus dem Puffer lesen */
	buffer = UDR;
 5c0:	80 91 2c 00 	lds	r24, 0x002C
 5c4:	89 83       	std	Y+1, r24	; 0x01

	/* warten bis der Sendepuffer leer ist */
	while ( !( UCSRA & (1<<UDRE)) );
 5c6:	80 91 2b 00 	lds	r24, 0x002B
 5ca:	99 27       	eor	r25, r25
 5cc:	80 72       	andi	r24, 0x20	; 32
 5ce:	90 70       	andi	r25, 0x00	; 0
 5d0:	00 97       	sbiw	r24, 0x00	; 0
 5d2:	09 f4       	brne	.+2      	; 0x5d6 <__vector_11+0x32>
 5d4:	f8 cf       	rjmp	.-16     	; 0x5c6 <__vector_11+0x22>
		
	/* und gleich wieder zurück schicken */
	UDR = buffer;
 5d6:	89 81       	ldd	r24, Y+1	; 0x01
 5d8:	80 93 2c 00 	sts	0x002C, r24
 5dc:	21 96       	adiw	r28, 0x01	; 1
 5de:	f8 94       	cli
 5e0:	de bf       	out	0x3e, r29	; 62
 5e2:	cd bf       	out	0x3d, r28	; 61
 5e4:	df 91       	pop	r29
 5e6:	cf 91       	pop	r28
 5e8:	9f 91       	pop	r25
 5ea:	8f 91       	pop	r24
 5ec:	0f 90       	pop	r0
 5ee:	0f be       	out	0x3f, r0	; 63
 5f0:	0f 90       	pop	r0
 5f2:	1f 90       	pop	r1
 5f4:	18 95       	reti

000005f6 <itoa>:
 5f6:	fb 01       	movw	r30, r22
 5f8:	9f 01       	movw	r18, r30
 5fa:	e8 94       	clt
 5fc:	42 30       	cpi	r20, 0x02	; 2
 5fe:	c4 f0       	brlt	.+48     	; 0x630 <itoa+0x3a>
 600:	45 32       	cpi	r20, 0x25	; 37
 602:	b4 f4       	brge	.+44     	; 0x630 <itoa+0x3a>
 604:	4a 30       	cpi	r20, 0x0A	; 10
 606:	29 f4       	brne	.+10     	; 0x612 <itoa+0x1c>
 608:	97 fb       	bst	r25, 7
 60a:	1e f4       	brtc	.+6      	; 0x612 <itoa+0x1c>
 60c:	90 95       	com	r25
 60e:	81 95       	neg	r24
 610:	9f 4f       	sbci	r25, 0xFF	; 255
 612:	64 2f       	mov	r22, r20
 614:	77 27       	eor	r23, r23
 616:	0e 94 2c 03 	call	0x658 <__udivmodhi4>
 61a:	80 5d       	subi	r24, 0xD0	; 208
 61c:	8a 33       	cpi	r24, 0x3A	; 58
 61e:	0c f0       	brlt	.+2      	; 0x622 <itoa+0x2c>
 620:	89 5d       	subi	r24, 0xD9	; 217
 622:	81 93       	st	Z+, r24
 624:	cb 01       	movw	r24, r22
 626:	00 97       	sbiw	r24, 0x00	; 0
 628:	a1 f7       	brne	.-24     	; 0x612 <itoa+0x1c>
 62a:	16 f4       	brtc	.+4      	; 0x630 <itoa+0x3a>
 62c:	5d e2       	ldi	r21, 0x2D	; 45
 62e:	51 93       	st	Z+, r21
 630:	10 82       	st	Z, r1
 632:	c9 01       	movw	r24, r18
 634:	0c 94 1c 03 	jmp	0x638 <strrev>

00000638 <strrev>:
 638:	dc 01       	movw	r26, r24
 63a:	fc 01       	movw	r30, r24
 63c:	01 90       	ld	r0, Z+
 63e:	00 20       	and	r0, r0
 640:	e9 f7       	brne	.-6      	; 0x63c <strrev+0x4>
 642:	32 97       	sbiw	r30, 0x02	; 2
 644:	ae 17       	cp	r26, r30
 646:	bf 07       	cpc	r27, r31
 648:	30 f4       	brcc	.+12     	; 0x656 <strrev+0x1e>
 64a:	7c 91       	ld	r23, X
 64c:	60 81       	ld	r22, Z
 64e:	70 83       	st	Z, r23
 650:	31 97       	sbiw	r30, 0x01	; 1
 652:	6d 93       	st	X+, r22
 654:	f7 cf       	rjmp	.-18     	; 0x644 <strrev+0xc>
 656:	08 95       	ret

00000658 <__udivmodhi4>:
 658:	aa 1b       	sub	r26, r26
 65a:	bb 1b       	sub	r27, r27
 65c:	51 e1       	ldi	r21, 0x11	; 17
 65e:	07 c0       	rjmp	.+14     	; 0x66e <__udivmodhi4_ep>

00000660 <__udivmodhi4_loop>:
 660:	aa 1f       	adc	r26, r26
 662:	bb 1f       	adc	r27, r27
 664:	a6 17       	cp	r26, r22
 666:	b7 07       	cpc	r27, r23
 668:	10 f0       	brcs	.+4      	; 0x66e <__udivmodhi4_ep>
 66a:	a6 1b       	sub	r26, r22
 66c:	b7 0b       	sbc	r27, r23

0000066e <__udivmodhi4_ep>:
 66e:	88 1f       	adc	r24, r24
 670:	99 1f       	adc	r25, r25
 672:	5a 95       	dec	r21
 674:	a9 f7       	brne	.-22     	; 0x660 <__udivmodhi4_loop>
 676:	80 95       	com	r24
 678:	90 95       	com	r25
 67a:	bc 01       	movw	r22, r24
 67c:	cd 01       	movw	r24, r26
 67e:	08 95       	ret

00000680 <_exit>:
 680:	ff cf       	rjmp	.-2      	; 0x680 <_exit>
