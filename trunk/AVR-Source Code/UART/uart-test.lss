
uart-test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001bc  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a0  00800060  000001bc  00000250  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00800100  0000025c  000002f0  2**0
                  ALLOC
  3 .noinit       00000000  00800100  00800100  000002f0  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  000002f0  2**0
                  CONTENTS
  5 .stab         00000960  00000000  00000000  000002f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      000007a8  00000000  00000000  00000c50  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54 <__ctors_end>
   4:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
   8:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
   c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  10:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  14:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  18:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  1c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  20:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  24:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  28:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  2c:	0c 94 b5 00 	jmp	0x16a <__vector_11>
  30:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  34:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  38:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  3c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  40:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  44:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  48:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  4c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
  50:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ec eb       	ldi	r30, 0xBC	; 188
  68:	f1 e0       	ldi	r31, 0x01	; 1
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a0 30       	cpi	r26, 0x00	; 0
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	a0 e0       	ldi	r26, 0x00	; 0
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 30       	cpi	r26, 0x00	; 0
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0c 94 47 00 	jmp	0x8e <main>

0000008a <__bad_interrupt>:
  8a:	0c 94 00 00 	jmp	0x0 <__vectors>

0000008e <main>:
#include <avr/interrupt.h>
#include "uart.h"

int main(void)
{	
  8e:	cf e5       	ldi	r28, 0x5F	; 95
  90:	d4 e0       	ldi	r29, 0x04	; 4
  92:	de bf       	out	0x3e, r29	; 62
  94:	cd bf       	out	0x3d, r28	; 61
	// USART initialisieren 
	uart_init();
  96:	0e 94 5f 00 	call	0xbe <uart_init>
	
	sei();	//global Interrupts Aktivieren
  9a:	78 94       	sei
	 
	uart_puts("\r ***         balance Bot             ***\r");
  9c:	80 e6       	ldi	r24, 0x60	; 96
  9e:	90 e0       	ldi	r25, 0x00	; 0
  a0:	0e 94 90 00 	call	0x120 <uart_puts>
	uart_puts(  " ** Hier werden zu Debugzwecken       **\r");
  a4:	8b e8       	ldi	r24, 0x8B	; 139
  a6:	90 e0       	ldi	r25, 0x00	; 0
  a8:	0e 94 90 00 	call	0x120 <uart_puts>
	uart_puts(  " ** einige statusmeldungen ausgegeben **\r\r");
  ac:	85 eb       	ldi	r24, 0xB5	; 181
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	0e 94 90 00 	call	0x120 <uart_puts>
	
	uart_puts(" UART inizialisierung ... OK \r");
  b4:	80 ee       	ldi	r24, 0xE0	; 224
  b6:	90 e0       	ldi	r25, 0x00	; 0
  b8:	0e 94 90 00 	call	0x120 <uart_puts>
	// Nichts tun. Die Interrupts erledigten den Rest 
	while (1)
  bc:	ff cf       	rjmp	.-2      	; 0xbc <main+0x2e>

000000be <uart_init>:
#include <avr/interrupt.h>
#include "uart.h"

void uart_init(void)
{
  be:	cf 93       	push	r28
  c0:	df 93       	push	r29
  c2:	cd b7       	in	r28, 0x3d	; 61
  c4:	de b7       	in	r29, 0x3e	; 62
	/* Baudrate einstellen ( Normaler Modus ) */
	UBRRH = (unsigned char) (UBRR_BAUD>>8);
  c6:	10 92 40 00 	sts	0x0040, r1
	UBRRL = (unsigned char) UBRR_BAUD;
  ca:	85 e0       	ldi	r24, 0x05	; 5
  cc:	80 93 29 00 	sts	0x0029, r24

	/* Aktivieren des Empfängers, des Senders und des "Daten empfangen"-Interrupts */
	UCSRB = (1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
  d0:	88 e9       	ldi	r24, 0x98	; 152
  d2:	80 93 2a 00 	sts	0x002A, r24

	/* Einstellen des Datenformats: 8 Datenbits, 1 Stoppbit */
	UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
  d6:	86 e8       	ldi	r24, 0x86	; 134
  d8:	80 93 40 00 	sts	0x0040, r24
  dc:	df 91       	pop	r29
  de:	cf 91       	pop	r28
  e0:	08 95       	ret

000000e2 <uart_putc>:
}

/** sendet ein einzelnes Zeichen **/
void uart_putc(char c)
{
  e2:	cf 93       	push	r28
  e4:	df 93       	push	r29
  e6:	cd b7       	in	r28, 0x3d	; 61
  e8:	de b7       	in	r29, 0x3e	; 62
  ea:	21 97       	sbiw	r28, 0x01	; 1
  ec:	0f b6       	in	r0, 0x3f	; 63
  ee:	f8 94       	cli
  f0:	de bf       	out	0x3e, r29	; 62
  f2:	0f be       	out	0x3f, r0	; 63
  f4:	cd bf       	out	0x3d, r28	; 61
  f6:	89 83       	std	Y+1, r24	; 0x01
	/* warten bis der Sendepuffer leer ist */
	while ( !( UCSRA & (1<<UDRE)) );
  f8:	80 91 2b 00 	lds	r24, 0x002B
  fc:	99 27       	eor	r25, r25
  fe:	80 72       	andi	r24, 0x20	; 32
 100:	90 70       	andi	r25, 0x00	; 0
 102:	00 97       	sbiw	r24, 0x00	; 0
 104:	09 f4       	brne	.+2      	; 0x108 <uart_putc+0x26>
 106:	f8 cf       	rjmp	.-16     	; 0xf8 <uart_putc+0x16>
	
	/* Zeichen senden */
	UDR = c;
 108:	89 81       	ldd	r24, Y+1	; 0x01
 10a:	80 93 2c 00 	sts	0x002C, r24
 10e:	21 96       	adiw	r28, 0x01	; 1
 110:	0f b6       	in	r0, 0x3f	; 63
 112:	f8 94       	cli
 114:	de bf       	out	0x3e, r29	; 62
 116:	0f be       	out	0x3f, r0	; 63
 118:	cd bf       	out	0x3d, r28	; 61
 11a:	df 91       	pop	r29
 11c:	cf 91       	pop	r28
 11e:	08 95       	ret

00000120 <uart_puts>:
}

/** sendet einen string **/
void uart_puts(char *s)
{
 120:	cf 93       	push	r28
 122:	df 93       	push	r29
 124:	cd b7       	in	r28, 0x3d	; 61
 126:	de b7       	in	r29, 0x3e	; 62
 128:	22 97       	sbiw	r28, 0x02	; 2
 12a:	0f b6       	in	r0, 0x3f	; 63
 12c:	f8 94       	cli
 12e:	de bf       	out	0x3e, r29	; 62
 130:	0f be       	out	0x3f, r0	; 63
 132:	cd bf       	out	0x3d, r28	; 61
 134:	9a 83       	std	Y+2, r25	; 0x02
 136:	89 83       	std	Y+1, r24	; 0x01
	while (*s) // so lange senden, bis das ende des Strings erreicht ist
 138:	e9 81       	ldd	r30, Y+1	; 0x01
 13a:	fa 81       	ldd	r31, Y+2	; 0x02
 13c:	80 81       	ld	r24, Z
 13e:	88 23       	and	r24, r24
 140:	59 f0       	breq	.+22     	; 0x158 <uart_puts+0x38>
	{
		uart_putc(*s);
 142:	e9 81       	ldd	r30, Y+1	; 0x01
 144:	fa 81       	ldd	r31, Y+2	; 0x02
 146:	80 81       	ld	r24, Z
 148:	0e 94 71 00 	call	0xe2 <uart_putc>
		s++;
 14c:	89 81       	ldd	r24, Y+1	; 0x01
 14e:	9a 81       	ldd	r25, Y+2	; 0x02
 150:	01 96       	adiw	r24, 0x01	; 1
 152:	9a 83       	std	Y+2, r25	; 0x02
 154:	89 83       	std	Y+1, r24	; 0x01
 156:	f0 cf       	rjmp	.-32     	; 0x138 <uart_puts+0x18>
 158:	22 96       	adiw	r28, 0x02	; 2
 15a:	0f b6       	in	r0, 0x3f	; 63
 15c:	f8 94       	cli
 15e:	de bf       	out	0x3e, r29	; 62
 160:	0f be       	out	0x3f, r0	; 63
 162:	cd bf       	out	0x3d, r28	; 61
 164:	df 91       	pop	r29
 166:	cf 91       	pop	r28
 168:	08 95       	ret

0000016a <__vector_11>:
	}
}



/* Interrupt wird ausgelöst sobald neue Daten im USART-Empfangspuffer liegen */
ISR(USART_RXC_vect)
{
 16a:	1f 92       	push	r1
 16c:	0f 92       	push	r0
 16e:	0f b6       	in	r0, 0x3f	; 63
 170:	0f 92       	push	r0
 172:	11 24       	eor	r1, r1
 174:	8f 93       	push	r24
 176:	9f 93       	push	r25
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	cd b7       	in	r28, 0x3d	; 61
 17e:	de b7       	in	r29, 0x3e	; 62
 180:	21 97       	sbiw	r28, 0x01	; 1
 182:	de bf       	out	0x3e, r29	; 62
 184:	cd bf       	out	0x3d, r28	; 61
	 
	unsigned char buffer;

	/* Daten aus dem Puffer lesen */
	buffer = UDR;
 186:	80 91 2c 00 	lds	r24, 0x002C
 18a:	89 83       	std	Y+1, r24	; 0x01

	/* warten bis der Sendepuffer leer ist */
	while ( !( UCSRA & (1<<UDRE)) );
 18c:	80 91 2b 00 	lds	r24, 0x002B
 190:	99 27       	eor	r25, r25
 192:	80 72       	andi	r24, 0x20	; 32
 194:	90 70       	andi	r25, 0x00	; 0
 196:	00 97       	sbiw	r24, 0x00	; 0
 198:	09 f4       	brne	.+2      	; 0x19c <__vector_11+0x32>
 19a:	f8 cf       	rjmp	.-16     	; 0x18c <__vector_11+0x22>
		
	/* und gleich wieder zurück schicken */
	UDR = buffer;
 19c:	89 81       	ldd	r24, Y+1	; 0x01
 19e:	80 93 2c 00 	sts	0x002C, r24
 1a2:	21 96       	adiw	r28, 0x01	; 1
 1a4:	f8 94       	cli
 1a6:	de bf       	out	0x3e, r29	; 62
 1a8:	cd bf       	out	0x3d, r28	; 61
 1aa:	df 91       	pop	r29
 1ac:	cf 91       	pop	r28
 1ae:	9f 91       	pop	r25
 1b0:	8f 91       	pop	r24
 1b2:	0f 90       	pop	r0
 1b4:	0f be       	out	0x3f, r0	; 63
 1b6:	0f 90       	pop	r0
 1b8:	1f 90       	pop	r1
 1ba:	18 95       	reti
