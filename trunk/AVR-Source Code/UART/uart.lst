   1               		.file	"uart.c"
   2               		.arch atmega16
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  76               	.global	uart_init
  78               	uart_init:
   1:uart.c        **** #include <avr/interrupt.h>
   2:uart.c        **** #include "uart.h"
   3:uart.c        **** 
   4:uart.c        **** void uart_init(void)
   5:uart.c        **** {
  80               	.LM1:
  81               	/* prologue: frame size=0 */
  82 0000 CF93      		push r28
  83 0002 DF93      		push r29
  84 0004 CDB7      		in r28,__SP_L__
  85 0006 DEB7      		in r29,__SP_H__
  86               	/* prologue end (size=4) */
   6:uart.c        **** 	/* Baudrate einstellen ( Normaler Modus ) */
   7:uart.c        **** 	UBRRH = (unsigned char) (UBRR_BAUD>>8);
  88               	.LM2:
  89 0008 1092 4000 		sts 64,__zero_reg__
   8:uart.c        **** 	UBRRL = (unsigned char) UBRR_BAUD;
  91               	.LM3:
  92 000c 85E0      		ldi r24,lo8(5)
  93 000e 8093 2900 		sts 41,r24
   9:uart.c        **** 
  10:uart.c        **** 	/* Aktivieren des Empfängers, des Senders und des "Daten empfangen"-Interrupts */
  11:uart.c        **** 	UCSRB = (1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
  95               	.LM4:
  96 0012 88E9      		ldi r24,lo8(-104)
  97 0014 8093 2A00 		sts 42,r24
  12:uart.c        **** 
  13:uart.c        **** 	/* Einstellen des Datenformats: 8 Datenbits, 1 Stoppbit */
  14:uart.c        **** 	UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
  99               	.LM5:
 100 0018 86E8      		ldi r24,lo8(-122)
 101 001a 8093 4000 		sts 64,r24
 102               	/* epilogue: frame size=0 */
 103 001e DF91      		pop r29
 104 0020 CF91      		pop r28
 105 0022 0895      		ret
 106               	/* epilogue end (size=3) */
 107               	/* function uart_init size 18 (11) */
 109               	.Lscope0:
 112               	.global	uart_putc
 114               	uart_putc:
  15:uart.c        **** }
  16:uart.c        **** 
  17:uart.c        **** /** sendet ein einzelnes Zeichen **/
  18:uart.c        **** void uart_putc(char c)
  19:uart.c        **** {
 116               	.LM6:
 117               	/* prologue: frame size=1 */
 118 0024 CF93      		push r28
 119 0026 DF93      		push r29
 120 0028 CDB7      		in r28,__SP_L__
 121 002a DEB7      		in r29,__SP_H__
 122 002c 2197      		sbiw r28,1
 123 002e 0FB6      		in __tmp_reg__,__SREG__
 124 0030 F894      		cli
 125 0032 DEBF      		out __SP_H__,r29
 126 0034 0FBE      		out __SREG__,__tmp_reg__
 127 0036 CDBF      		out __SP_L__,r28
 128               	/* prologue end (size=10) */
 129 0038 8983      		std Y+1,r24
 130               	.L3:
  20:uart.c        **** 	/* warten bis der Sendepuffer leer ist */
  21:uart.c        **** 	while ( !( UCSRA & (1<<UDRE)) );
 132               	.LM7:
 133 003a 8091 2B00 		lds r24,43
 134 003e 9927      		clr r25
 135 0040 8072      		andi r24,lo8(32)
 136 0042 9070      		andi r25,hi8(32)
 137 0044 0097      		sbiw r24,0
 138 0046 09F4      		brne .L4
 139 0048 F8CF      		rjmp .L3
 140               	.L4:
  22:uart.c        **** 	
  23:uart.c        **** 	/* Zeichen senden */
  24:uart.c        **** 	UDR = c;
 142               	.LM8:
 143 004a 8981      		ldd r24,Y+1
 144 004c 8093 2C00 		sts 44,r24
 145               	/* epilogue: frame size=1 */
 146 0050 2196      		adiw r28,1
 147 0052 0FB6      		in __tmp_reg__,__SREG__
 148 0054 F894      		cli
 149 0056 DEBF      		out __SP_H__,r29
 150 0058 0FBE      		out __SREG__,__tmp_reg__
 151 005a CDBF      		out __SP_L__,r28
 152 005c DF91      		pop r29
 153 005e CF91      		pop r28
 154 0060 0895      		ret
 155               	/* epilogue end (size=9) */
 156               	/* function uart_putc size 31 (12) */
 158               	.Lscope1:
 161               	.global	uart_puts
 163               	uart_puts:
  25:uart.c        **** }
  26:uart.c        **** 
  27:uart.c        **** /** sendet einen string **/
  28:uart.c        **** void uart_puts(char *s)
  29:uart.c        **** {
 165               	.LM9:
 166               	/* prologue: frame size=2 */
 167 0062 CF93      		push r28
 168 0064 DF93      		push r29
 169 0066 CDB7      		in r28,__SP_L__
 170 0068 DEB7      		in r29,__SP_H__
 171 006a 2297      		sbiw r28,2
 172 006c 0FB6      		in __tmp_reg__,__SREG__
 173 006e F894      		cli
 174 0070 DEBF      		out __SP_H__,r29
 175 0072 0FBE      		out __SREG__,__tmp_reg__
 176 0074 CDBF      		out __SP_L__,r28
 177               	/* prologue end (size=10) */
 178 0076 9A83      		std Y+2,r25
 179 0078 8983      		std Y+1,r24
 180               	.L6:
  30:uart.c        **** 	while (*s) // so lange senden, bis das ende des Strings erreicht ist
 182               	.LM10:
 183 007a E981      		ldd r30,Y+1
 184 007c FA81      		ldd r31,Y+2
 185 007e 8081      		ld r24,Z
 186 0080 8823      		tst r24
 187 0082 59F0      		breq .L5
  31:uart.c        **** 	{
  32:uart.c        **** 		uart_putc(*s);
 189               	.LM11:
 190 0084 E981      		ldd r30,Y+1
 191 0086 FA81      		ldd r31,Y+2
 192 0088 8081      		ld r24,Z
 193 008a 0E94 0000 		call uart_putc
  33:uart.c        **** 		s++;
 195               	.LM12:
 196 008e 8981      		ldd r24,Y+1
 197 0090 9A81      		ldd r25,Y+2
 198 0092 0196      		adiw r24,1
 199 0094 9A83      		std Y+2,r25
 200 0096 8983      		std Y+1,r24
 201 0098 F0CF      		rjmp .L6
 202               	.L5:
 203               	/* epilogue: frame size=2 */
 204 009a 2296      		adiw r28,2
 205 009c 0FB6      		in __tmp_reg__,__SREG__
 206 009e F894      		cli
 207 00a0 DEBF      		out __SP_H__,r29
 208 00a2 0FBE      		out __SREG__,__tmp_reg__
 209 00a4 CDBF      		out __SP_L__,r28
 210 00a6 DF91      		pop r29
 211 00a8 CF91      		pop r28
 212 00aa 0895      		ret
 213               	/* epilogue end (size=9) */
 214               	/* function uart_puts size 37 (18) */
 216               	.Lscope2:
 218               	.global	__vector_11
 220               	__vector_11:
  34:uart.c        **** 	}
  35:uart.c        **** }
  36:uart.c        **** 
  37:uart.c        **** 
  38:uart.c        **** 
  39:uart.c        **** /* Interrupt wird ausgelöst sobald neue Daten im USART-Empfangspuffer liegen */
  40:uart.c        **** ISR(USART_RXC_vect)
  41:uart.c        **** {
 222               	.LM13:
 223               	/* prologue: frame size=1 */
 224 00ac 1F92      		push __zero_reg__
 225 00ae 0F92      		push __tmp_reg__
 226 00b0 0FB6      		in __tmp_reg__,__SREG__
 227 00b2 0F92      		push __tmp_reg__
 228 00b4 1124      		clr __zero_reg__
 229 00b6 8F93      		push r24
 230 00b8 9F93      		push r25
 231 00ba CF93      		push r28
 232 00bc DF93      		push r29
 233 00be CDB7      		in r28,__SP_L__
 234 00c0 DEB7      		in r29,__SP_H__
 235 00c2 2197      		sbiw r28,1
 236 00c4 DEBF      		out __SP_H__,r29
 237 00c6 CDBF      		out __SP_L__,r28
 238               	/* prologue end (size=14) */
  42:uart.c        **** 	 
  43:uart.c        **** 	unsigned char buffer;
  44:uart.c        **** 
  45:uart.c        **** 	/* Daten aus dem Puffer lesen */
  46:uart.c        **** 	buffer = UDR;
 240               	.LM14:
 241 00c8 8091 2C00 		lds r24,44
 242 00cc 8983      		std Y+1,r24
 243               	.L9:
  47:uart.c        **** 
  48:uart.c        **** 	/* warten bis der Sendepuffer leer ist */
  49:uart.c        **** 	while ( !( UCSRA & (1<<UDRE)) );
 245               	.LM15:
 246 00ce 8091 2B00 		lds r24,43
 247 00d2 9927      		clr r25
 248 00d4 8072      		andi r24,lo8(32)
 249 00d6 9070      		andi r25,hi8(32)
 250 00d8 0097      		sbiw r24,0
 251 00da 09F4      		brne .L10
 252 00dc F8CF      		rjmp .L9
 253               	.L10:
  50:uart.c        **** 		
  51:uart.c        **** 	/* und gleich wieder zurück schicken */
  52:uart.c        **** 	UDR = buffer;
 255               	.LM16:
 256 00de 8981      		ldd r24,Y+1
 257 00e0 8093 2C00 		sts 44,r24
 258               	/* epilogue: frame size=1 */
 259 00e4 2196      		adiw r28,1
 260 00e6 F894      		cli
 261 00e8 DEBF      		out __SP_H__,r29
 262 00ea CDBF      		out __SP_L__,r28
 263 00ec DF91      		pop r29
 264 00ee CF91      		pop r28
 265 00f0 9F91      		pop r25
 266 00f2 8F91      		pop r24
 267 00f4 0F90      		pop __tmp_reg__
 268 00f6 0FBE      		out __SREG__,__tmp_reg__
 269 00f8 0F90      		pop __tmp_reg__
 270 00fa 1F90      		pop __zero_reg__
 271 00fc 1895      		reti
 272               	/* epilogue end (size=13) */
 273               	/* function __vector_11 size 41 (14) */
 278               	.Lscope3:
 279               		.text
 281               	Letext:
 282               	/* File "uart.c": code  127 = 0x007f (  55), prologues  38, epilogues  34 */
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:3      *ABS*:0000003f __SREG__
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:4      *ABS*:0000003e __SP_H__
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:5      *ABS*:0000003d __SP_L__
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:6      *ABS*:00000000 __tmp_reg__
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:7      *ABS*:00000001 __zero_reg__
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:78     .text:00000000 uart_init
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:114    .text:00000024 uart_putc
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:163    .text:00000062 uart_puts
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:220    .text:000000ac __vector_11
C:\DOKUME~1\Olaf\LOKALE~1\Temp/ccecbaaa.s:281    .text:000000fe Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
