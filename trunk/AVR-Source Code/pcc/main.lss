
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001416  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000044  00800060  00001416  000014aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000084  008000a4  008000a4  000014ee  2**0
                  ALLOC
  3 .noinit       00000000  00800128  00800128  000014ee  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  000014ee  2**0
                  CONTENTS
  5 .stab         0000036c  00000000  00000000  000014f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000084  00000000  00000000  0000185c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000000a0  00000000  00000000  000018e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000337  00000000  00000000  00001980  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0000113d  00000000  00000000  00001cb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000005df  00000000  00000000  00002df4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00000e3e  00000000  00000000  000033d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000002a2  00000000  00000000  00004211  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 58 02 	jmp	0x4b0 <__init>
       4:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
       8:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
       c:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      10:	0c 94 f7 05 	jmp	0xbee <__vector_4>
      14:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      18:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      1c:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      20:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      24:	0c 94 fd 02 	jmp	0x5fa <__vector_9>
      28:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      2c:	0c 94 77 05 	jmp	0xaee <__vector_11>
      30:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      34:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      38:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      3c:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      40:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      44:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      48:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      4c:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>
      50:	0c 94 73 02 	jmp	0x4e6 <__bad_interrupt>

00000054 <Str_CR>:
      54:	0d 0a 00                                            ...

00000057 <Str_BOT>:
      57:	42 4f 54 3a 5c 3e 00                                BOT:\>.

0000005e <__c.0>:
      5e:	0d 0a 20 44 69 65 73 65 6e 20 42 65 66 65 68 6c     .. Diesen Befehl
      6e:	20 6b 65 6e 6e 65 20 69 63 68 20 6e 69 63 68 74      kenne ich nicht
      7e:	2e 0d 0a 00                                         ....

00000082 <__c.1>:
      82:	20 44 75 20 68 61 73 74 20 22 00                     Du hast ".

0000008d <__c.2>:
      8d:	22 20 65 69 6e 67 65 67 65 62 65 6e 2e 20 00        " eingegeben. .

0000009c <__c.3>:
      9c:	0c 20 2a 2a 2a 20 48 61 6c 6c 6f 21 20 2a 2a 2a     . *** Hallo! ***
	...

000000ad <__c.4>:
      ad:	20 49 63 68 20 62 69 6e 20 65 69 6e 20 6b 6c 65      Ich bin ein kle
      bd:	69 6e 65 72 20 52 6f 62 6f 74 65 72 2e 20 57 61     iner Roboter. Wa
      cd:	73 20 6d 6f 65 63 68 74 65 73 74 20 64 75 20 6d     s moechtest du m
      dd:	69 74 20 6d 69 72 20 6d 61 63 68 65 6e 3f 00        it mir machen?.

000000ec <__c.5>:
      ec:	20 4d 69 74 20 64 65 6d 20 42 65 66 65 68 6c 3a      Mit dem Befehl:
	...

000000fd <__c.6>:
      fd:	20 2d 20 3f 20 20 20 20 20 20 20 5a 65 69 67 65      - ?       Zeige
     10d:	20 69 63 68 20 64 69 65 20 61 6c 6c 65 20 42 65      ich die alle Be
     11d:	66 65 68 6c 65 20 64 69 65 20 69 63 68 20 76 65     fehle die ich ve
     12d:	72 73 74 65 68 65 2e 00                             rstehe..

00000135 <__c.7>:
     135:	20 2d 20 73 74 61 74 75 73 20 20 6b 61 6e 6e 73      - status  kanns
     145:	74 20 64 75 20 73 65 68 65 6e 2c 20 77 69 65 20     t du sehen, wie 
     155:	69 63 68 20 6d 69 63 68 20 66 75 65 68 6c 65 2e     ich mich fuehle.
	...

00000166 <__c.8>:
     166:	20 2d 20 63 6c 73 20 20 20 20 20 6c 6f 65 73 63      - cls     loesc
     176:	68 74 20 64 75 20 64 65 6e 20 42 69 6c 64 73 63     ht du den Bildsc
     186:	68 69 72 6d 2e 00                                   hirm..

0000018c <__c.9>:
     18c:	20 2d 20 6d 6f 76 65 20 20 20 20 6b 61 6e 6e 73      - move    kanns
     19c:	74 20 64 75 20 6d 69 63 68 20 66 61 68 72 65 6e     t du mich fahren
     1ac:	20 6c 61 73 73 65 6e 2e 00                           lassen..

000001b5 <__c.10>:
     1b5:	20 2d 20 64 65 6d 6f 20 20 20 20 66 61 68 72 65      - demo    fahre
     1c5:	20 69 63 68 20 65 69 6e 20 77 65 6e 69 67 20 68      ich ein wenig h
     1d5:	69 6e 20 75 6e 64 20 68 65 72 2e 00                 in und her..

000001e1 <__c.11>:
     1e1:	20 2d 20 64 65 62 75 67 20 20 20 5a 65 69 67 65      - debug   Zeige
     1f1:	20 69 63 68 20 64 69 72 20 41 6b 74 75 65 6c 6c      ich dir Aktuell
     201:	65 20 53 74 61 74 75 73 6d 65 6c 64 75 6e 67 65     e Statusmeldunge
     211:	6e 2e 00                                            n..

00000214 <__c.12>:
     214:	0c 20 2a 2a 2a 20 48 69 21 20 2a 2a 2a 0d 0a 00     . *** Hi! ***...

00000224 <__c.13>:
     224:	20 49 63 68 20 62 69 6e 20 68 65 75 74 65 20 73      Ich bin heute s
     234:	63 68 6f 6e 20 73 65 69 74 20 00                    chon seit .

0000023f <__c.14>:
     23f:	20 75 6e 74 65 72 77 65 67 73 2e 0d 0a 00            unterwegs....

0000024d <__c.15>:
     24d:	20 49 63 68 20 66 75 65 68 6c 65 20 6d 69 63 68      Ich fuehle mich
     25d:	20 67 75 74 20 75 6e 64 20 6d 65 69 6e 65 20 41      gut und meine A
     26d:	6b 6b 75 73 70 61 6e 6e 75 6e 67 20 62 65 74 72     kkuspannung betr
     27d:	61 65 67 74 20 6e 6f 63 68 3a 00                    aegt noch:.

00000288 <__c.16>:
     288:	20 31 32 56 0d 0a 00                                 12V...

0000028f <__c.17>:
     28f:	0c 20 2a 2a 2a 20 47 69 62 20 47 61 73 21 20 2a     . *** Gib Gas! *
     29f:	2a 2a 0d 0a 00                                      **...

000002a4 <__c.18>:
     2a4:	20 4d 69 74 20 64 65 6e 20 50 66 65 69 6c 74 61      Mit den Pfeilta
     2b4:	73 74 65 6e 20 6b 61 6e 6e 73 74 20 64 75 20 6d     sten kannst du m
     2c4:	69 63 68 20 6e 75 6e 20 73 74 65 75 65 72 6e 2e     ich nun steuern.
     2d4:	0d 0a 00                                            ...

000002d7 <__c.19>:
     2d7:	20 4d 69 74 20 45 73 63 20 62 65 65 6e 64 65 73      Mit Esc beendes
     2e7:	74 20 64 75 20 64 69 65 20 46 61 68 72 74 2e 00     t du die Fahrt..

000002f7 <__c.20>:
     2f7:	0c 20 2a 2a 2a 20 44 45 4d 4f 20 2a 2a 2a 20 0d     . *** DEMO *** .
     307:	0a 00                                               ..

00000309 <__c.21>:
     309:	20 49 63 68 20 66 61 68 72 65 20 65 69 6e 20 77      Ich fahre ein w
     319:	65 6e 69 67 20 68 69 6e 20 75 6e 64 20 68 65 72     enig hin und her
     329:	2e 0d 0a 00                                         ....

0000032d <__c.22>:
     32d:	20 4d 69 74 20 45 73 63 20 62 65 65 6e 64 65 73      Mit Esc beendes
     33d:	74 20 64 75 20 64 69 65 20 46 61 68 72 74 2e 00     t du die Fahrt..

0000034d <__c.23>:
     34d:	0c 20 2a 2a 2a 20 44 45 42 55 47 20 2a 2a 2a 20     . *** DEBUG *** 
     35d:	0d 0a 00                                            ...

00000360 <__c.24>:
     360:	20 49 63 68 20 6b 61 6e 6e 20 64 69 72 20 76 65      Ich kann dir ve
     370:	72 73 63 68 69 65 64 65 6e 65 20 44 45 42 55 47     rschiedene DEBUG
     380:	69 6e 66 6f 6d 61 74 69 6f 6e 65 6e 20 61 75 73     infomationen aus
     390:	67 65 62 65 6e 3a 0d 0a 00                          geben:...

00000399 <__c.25>:
     399:	20 4d 69 74 20 64 65 6d 20 42 65 66 65 68 6c 3a      Mit dem Befehl:
     3a9:	0d 0a 00                                            ...

000003ac <__c.26>:
     3ac:	20 2d 20 64 65 62 75 67 20 63 6d 64 20 20 20 20      - debug cmd    
     3bc:	20 20 67 65 62 65 20 69 63 68 20 64 69 72 20 61       gebe ich dir a
     3cc:	6c 6c 65 20 67 65 73 65 6e 64 65 74 65 20 5a 65     lle gesendete Ze
     3dc:	69 63 68 65 6e 20 61 75 73 2e 0d 0a 00              ichen aus....

000003e9 <__c.27>:
     3e9:	20 2d 20 64 65 62 75 67 20 65 6e 63 20 20 20 20      - debug enc    
     3f9:	20 20 67 65 62 65 20 69 63 68 20 64 69 65 20 64       gebe ich die d
     409:	69 65 20 61 6b 74 75 65 6c 6c 65 6e 20 45 6e 63     ie aktuellen Enc
     419:	6f 64 65 72 77 65 72 74 65 20 61 75 73 2e 0d 0a     oderwerte aus...
	...

0000042a <__c.28>:
     42a:	20 2d 20 64 65 62 75 67 20 72 65 67 20 20 20 20      - debug reg    
     43a:	20 20 67 65 62 65 20 69 63 68 20 64 69 72 20 61       gebe ich dir a
     44a:	6b 74 75 65 6c 6c 65 20 52 65 67 6c 65 72 77 65     ktuelle Reglerwe
     45a:	72 74 65 20 61 75 73 2e 0d 0a 00                    rte aus....

00000465 <__c.29>:
     465:	20 2d 20 44 69 65 20 41 6e 7a 65 69 67 65 20 62      - Die Anzeige b
     475:	65 65 6e 64 65 73 74 20 64 75 20 6d 69 74 20 65     eendest du mit e
     485:	73 63 61 70 65 2e 0d 0a 00                          scape....

0000048e <__c.30>:
     48e:	0c 00                                               ..

00000490 <__c.31>:
     490:	0c 20 46 65 68 6c 65 72 20 69 6e 20 64 65 72 20     . Fehler in der 
     4a0:	43 6f 6d 6d 61 6e 64 6c 69 6e 65 21 21 0d 0a 00     Commandline!!...

000004b0 <__init>:
     4b0:	11 24       	eor	r1, r1
     4b2:	1f be       	out	0x3f, r1	; 63
     4b4:	cf e5       	ldi	r28, 0x5F	; 95
     4b6:	d4 e0       	ldi	r29, 0x04	; 4
     4b8:	de bf       	out	0x3e, r29	; 62
     4ba:	cd bf       	out	0x3d, r28	; 61

000004bc <__do_copy_data>:
     4bc:	10 e0       	ldi	r17, 0x00	; 0
     4be:	a0 e6       	ldi	r26, 0x60	; 96
     4c0:	b0 e0       	ldi	r27, 0x00	; 0
     4c2:	e6 e1       	ldi	r30, 0x16	; 22
     4c4:	f4 e1       	ldi	r31, 0x14	; 20
     4c6:	02 c0       	rjmp	.+4      	; 0x4cc <.do_copy_data_start>

000004c8 <.do_copy_data_loop>:
     4c8:	05 90       	lpm	r0, Z+
     4ca:	0d 92       	st	X+, r0

000004cc <.do_copy_data_start>:
     4cc:	a4 3a       	cpi	r26, 0xA4	; 164
     4ce:	b1 07       	cpc	r27, r17
     4d0:	d9 f7       	brne	.-10     	; 0x4c8 <.do_copy_data_loop>

000004d2 <__do_clear_bss>:
     4d2:	11 e0       	ldi	r17, 0x01	; 1
     4d4:	a4 ea       	ldi	r26, 0xA4	; 164
     4d6:	b0 e0       	ldi	r27, 0x00	; 0
     4d8:	01 c0       	rjmp	.+2      	; 0x4dc <.do_clear_bss_start>

000004da <.do_clear_bss_loop>:
     4da:	1d 92       	st	X+, r1

000004dc <.do_clear_bss_start>:
     4dc:	a8 32       	cpi	r26, 0x28	; 40
     4de:	b1 07       	cpc	r27, r17
     4e0:	e1 f7       	brne	.-8      	; 0x4da <.do_clear_bss_loop>
     4e2:	0c 94 75 02 	jmp	0x4ea <main>

000004e6 <__bad_interrupt>:
     4e6:	0c 94 00 00 	jmp	0x0 <__vectors>

000004ea <main>:



int main(void)
{
     4ea:	c7 e5       	ldi	r28, 0x57	; 87
     4ec:	d4 e0       	ldi	r29, 0x04	; 4
     4ee:	de bf       	out	0x3e, r29	; 62
     4f0:	cd bf       	out	0x3d, r28	; 61
	uart_init();
     4f2:	0e 94 55 03 	call	0x6aa <uart_init>
	timer2_init();
     4f6:	0e 94 b6 05 	call	0xb6c <timer2_init>
	
	uint32_t zeit = 0;
     4fa:	19 82       	std	Y+1, r1	; 0x01
     4fc:	1a 82       	std	Y+2, r1	; 0x02
     4fe:	1b 82       	std	Y+3, r1	; 0x03
     500:	1c 82       	std	Y+4, r1	; 0x04
	
	uint16_t x;
	uint16_t y;
	
	sei();
     502:	78 94       	sei
	for(;;)
	{
		if (Gettime() >= (zeit + 100))		// alle 100ms
     504:	0e 94 bc 05 	call	0xb78 <Gettime>
     508:	dc 01       	movw	r26, r24
     50a:	cb 01       	movw	r24, r22
     50c:	29 81       	ldd	r18, Y+1	; 0x01
     50e:	3a 81       	ldd	r19, Y+2	; 0x02
     510:	4b 81       	ldd	r20, Y+3	; 0x03
     512:	5c 81       	ldd	r21, Y+4	; 0x04
     514:	2c 59       	subi	r18, 0x9C	; 156
     516:	3f 4f       	sbci	r19, 0xFF	; 255
     518:	4f 4f       	sbci	r20, 0xFF	; 255
     51a:	5f 4f       	sbci	r21, 0xFF	; 255
     51c:	82 17       	cp	r24, r18
     51e:	93 07       	cpc	r25, r19
     520:	a4 07       	cpc	r26, r20
     522:	b5 07       	cpc	r27, r21
     524:	78 f3       	brcs	.-34     	; 0x504 <main+0x1a>
		{	
			pcc(uart_getc());		// PC Kommunikation
     526:	0e 94 4e 05 	call	0xa9c <uart_getc>
     52a:	0e 94 49 09 	call	0x1292 <pcc>
			x = Gettime();
     52e:	0e 94 bc 05 	call	0xb78 <Gettime>
     532:	dc 01       	movw	r26, r24
     534:	cb 01       	movw	r24, r22
     536:	9e 83       	std	Y+6, r25	; 0x06
     538:	8d 83       	std	Y+5, r24	; 0x05
			
			y = x*x;
     53a:	2d 81       	ldd	r18, Y+5	; 0x05
     53c:	3e 81       	ldd	r19, Y+6	; 0x06
     53e:	8d 81       	ldd	r24, Y+5	; 0x05
     540:	9e 81       	ldd	r25, Y+6	; 0x06
     542:	28 9f       	mul	r18, r24
     544:	a0 01       	movw	r20, r0
     546:	29 9f       	mul	r18, r25
     548:	50 0d       	add	r21, r0
     54a:	38 9f       	mul	r19, r24
     54c:	50 0d       	add	r21, r0
     54e:	11 24       	eor	r1, r1
     550:	ca 01       	movw	r24, r20
     552:	98 87       	std	Y+8, r25	; 0x08
     554:	8f 83       	std	Y+7, r24	; 0x07
			
			// encoder Links
			uart_putc(10);
     556:	8a e0       	ldi	r24, 0x0A	; 10
     558:	0e 94 6e 03 	call	0x6dc <uart_putc>
			uart_putc(x>>8);
     55c:	8d 81       	ldd	r24, Y+5	; 0x05
     55e:	9e 81       	ldd	r25, Y+6	; 0x06
     560:	89 2f       	mov	r24, r25
     562:	99 27       	eor	r25, r25
     564:	0e 94 6e 03 	call	0x6dc <uart_putc>
			uart_putc(x);
     568:	8d 81       	ldd	r24, Y+5	; 0x05
     56a:	0e 94 6e 03 	call	0x6dc <uart_putc>
			// encoder Rechts
			uart_putc(16);
     56e:	80 e1       	ldi	r24, 0x10	; 16
     570:	0e 94 6e 03 	call	0x6dc <uart_putc>
			uart_putc((y+5)>>8);
     574:	8f 81       	ldd	r24, Y+7	; 0x07
     576:	98 85       	ldd	r25, Y+8	; 0x08
     578:	05 96       	adiw	r24, 0x05	; 5
     57a:	89 2f       	mov	r24, r25
     57c:	99 27       	eor	r25, r25
     57e:	0e 94 6e 03 	call	0x6dc <uart_putc>
			uart_putc(y+5);
     582:	8f 81       	ldd	r24, Y+7	; 0x07
     584:	8b 5f       	subi	r24, 0xFB	; 251
     586:	0e 94 6e 03 	call	0x6dc <uart_putc>
     58a:	bc cf       	rjmp	.-136    	; 0x504 <main+0x1a>

0000058c <encoderGet>:
{
	int16_t r;							// rückgabewert
	uint8_t tmp_sreg;				// temporaerer Speicher fuer das Statusregister
	
	tmp_sreg = SREG;				// Statusregister (also auch das I-Flag darin) sichern
     58c:	2f b7       	in	r18, 0x3f	; 63
	cli();									// Interrupts global deaktivieren
     58e:	f8 94       	cli
	r = enc_delta[motor];		// Encoderwert speichern
     590:	e8 2f       	mov	r30, r24
     592:	ff 27       	eor	r31, r31
     594:	ee 0f       	add	r30, r30
     596:	ff 1f       	adc	r31, r31
     598:	e6 55       	subi	r30, 0x56	; 86
     59a:	ff 4f       	sbci	r31, 0xFF	; 255
     59c:	80 81       	ld	r24, Z
     59e:	91 81       	ldd	r25, Z+1	; 0x01
	enc_delta[motor]	= 0;	// enc_delta zurücksetzen
     5a0:	11 82       	std	Z+1, r1	; 0x01
     5a2:	10 82       	st	Z, r1
	SREG = tmp_sreg;				// Status-Register wieder herstellen 
     5a4:	2f bf       	out	0x3f, r18	; 63
     5a6:	08 95       	ret

000005a8 <encoder_init>:
     5a8:	84 b3       	in	r24, 0x14	; 20
     5aa:	80 7f       	andi	r24, 0xF0	; 240
     5ac:	84 bb       	out	0x14, r24	; 20
     5ae:	85 b3       	in	r24, 0x15	; 21
     5b0:	8f 60       	ori	r24, 0x0F	; 15
     5b2:	85 bb       	out	0x15, r24	; 21
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	0e 94 c6 02 	call	0x58c <encoderGet>
     5ba:	81 e0       	ldi	r24, 0x01	; 1
     5bc:	0e 94 c6 02 	call	0x58c <encoderGet>
     5c0:	82 e0       	ldi	r24, 0x02	; 2
     5c2:	83 bf       	out	0x33, r24	; 51
     5c4:	89 b7       	in	r24, 0x39	; 57
     5c6:	81 60       	ori	r24, 0x01	; 1
     5c8:	89 bf       	out	0x39, r24	; 57
     5ca:	08 95       	ret

000005cc <encoderToMM>:
	
	return r;							// Encoderwert zurückgeben
}


/**************************************************************************/
/*!
*	\brief Umrechner von EncoderFlanken nach mm
*
*	\param [in]
*	encoder	Wert der Umgerechnet werden soll
*
*	\return
*	Liefert die gefahrene strecke in mm zurück
***************************************************************************/
int32_t encoderToMM(int32_t encoder)
{
     5cc:	dc 01       	movw	r26, r24
     5ce:	cb 01       	movw	r24, r22
	return ((int32_t)(encoder*1000L)/UMRECHNUG_ECNODER_MM);
     5d0:	bc 01       	movw	r22, r24
     5d2:	cd 01       	movw	r24, r26
     5d4:	28 ee       	ldi	r18, 0xE8	; 232
     5d6:	33 e0       	ldi	r19, 0x03	; 3
     5d8:	40 e0       	ldi	r20, 0x00	; 0
     5da:	50 e0       	ldi	r21, 0x00	; 0
     5dc:	0e 94 9b 09 	call	0x1336 <__mulsi3>
     5e0:	dc 01       	movw	r26, r24
     5e2:	cb 01       	movw	r24, r22
     5e4:	bc 01       	movw	r22, r24
     5e6:	cd 01       	movw	r24, r26
     5e8:	22 e2       	ldi	r18, 0x22	; 34
     5ea:	33 e1       	ldi	r19, 0x13	; 19
     5ec:	40 e0       	ldi	r20, 0x00	; 0
     5ee:	50 e0       	ldi	r21, 0x00	; 0
     5f0:	0e 94 dc 09 	call	0x13b8 <__divmodsi4>
}
     5f4:	ca 01       	movw	r24, r20
     5f6:	b9 01       	movw	r22, r18
     5f8:	08 95       	ret

000005fa <__vector_9>:


/**************************************************************************/
/*!
* \brief timer mit 5,4kHz zur Encoder auswertung
*
* Es werden die Einganszustände des rechten Motor Eingelesen uns 
* Ausgewertet.
***************************************************************************/
ISR(TIMER0_OVF_vect)
{
     5fa:	1f 92       	push	r1
     5fc:	0f 92       	push	r0
     5fe:	0f b6       	in	r0, 0x3f	; 63
     600:	0f 92       	push	r0
     602:	11 24       	eor	r1, r1
     604:	2f 93       	push	r18
     606:	3f 93       	push	r19
     608:	4f 93       	push	r20
     60a:	5f 93       	push	r21
     60c:	8f 93       	push	r24
     60e:	9f 93       	push	r25
	static int8_t enc_last[] = {0x01, 0x01};
	int8_t i[] = {0, 0};
     610:	40 e0       	ldi	r20, 0x00	; 0
     612:	50 e0       	ldi	r21, 0x00	; 0

	// Einlesen der Signalzustände für den linken Encoder
	if( PHASE_LEFT_A )
     614:	9a 99       	sbic	0x13, 2	; 19
		i[LEFT] = 1;
     616:	41 e0       	ldi	r20, 0x01	; 1

	if( PHASE_LEFT_B )
     618:	9b 9b       	sbis	0x13, 3	; 19
     61a:	02 c0       	rjmp	.+4      	; 0x620 <__vector_9+0x26>
		i[LEFT] ^= 3;											// convert gray to binary
     61c:	83 e0       	ldi	r24, 0x03	; 3
     61e:	48 27       	eor	r20, r24
		
		// Einlesen der Signalzustände für den rechten Encoder
	if( PHASE_RIGHT_A )
     620:	98 99       	sbic	0x13, 0	; 19
		i[RIGHT] = 1;
     622:	51 e0       	ldi	r21, 0x01	; 1

	if( PHASE_RIGHT_B )
     624:	99 9b       	sbis	0x13, 1	; 19
     626:	02 c0       	rjmp	.+4      	; 0x62c <__vector_9+0x32>
		i[RIGHT] ^= 3;											// convert gray to binary	
     628:	83 e0       	ldi	r24, 0x03	; 3
     62a:	58 27       	eor	r21, r24
		
	// Auswerten des LINKEN Motor Encoders
	i[LEFT] -= enc_last[LEFT];					// difference new - last
     62c:	90 91 60 00 	lds	r25, 0x0060
     630:	84 2f       	mov	r24, r20
     632:	89 1b       	sub	r24, r25

	if( i[LEFT] & 1 ){									// bit 0 = value (1)
     634:	28 2f       	mov	r18, r24
     636:	33 27       	eor	r19, r19
     638:	27 fd       	sbrc	r18, 7
     63a:	30 95       	com	r19
     63c:	20 ff       	sbrs	r18, 0
     63e:	10 c0       	rjmp	.+32     	; 0x660 <__vector_9+0x66>
		enc_last[LEFT] += i[LEFT];				// store new as next last
     640:	98 0f       	add	r25, r24
     642:	90 93 60 00 	sts	0x0060, r25

		enc_delta[LEFT] += (i[LEFT] & 2) - 1;			// bit 1 = direction (+/-)
     646:	22 70       	andi	r18, 0x02	; 2
     648:	30 70       	andi	r19, 0x00	; 0
     64a:	80 91 aa 00 	lds	r24, 0x00AA
     64e:	90 91 ab 00 	lds	r25, 0x00AB
     652:	82 0f       	add	r24, r18
     654:	93 1f       	adc	r25, r19
     656:	01 97       	sbiw	r24, 0x01	; 1
     658:	90 93 ab 00 	sts	0x00AB, r25
     65c:	80 93 aa 00 	sts	0x00AA, r24
	}	
	
	// Auswerten des RECHTEN Motor Encoders
	i[RIGHT] -= enc_last[RIGHT];				// difference new - last
     660:	90 91 61 00 	lds	r25, 0x0061
     664:	85 2f       	mov	r24, r21
     666:	89 1b       	sub	r24, r25

	if( i[RIGHT] & 1 ){								// bit 0 = value (1)
     668:	28 2f       	mov	r18, r24
     66a:	33 27       	eor	r19, r19
     66c:	27 fd       	sbrc	r18, 7
     66e:	30 95       	com	r19
     670:	20 ff       	sbrs	r18, 0
     672:	10 c0       	rjmp	.+32     	; 0x694 <__vector_9+0x9a>
		enc_last[RIGHT] += i[RIGHT];			// store new as next last
     674:	98 0f       	add	r25, r24
     676:	90 93 61 00 	sts	0x0061, r25

		enc_delta[RIGHT] += (i[RIGHT] & 2) - 1;		// bit 1 = direction (+/-)
     67a:	22 70       	andi	r18, 0x02	; 2
     67c:	30 70       	andi	r19, 0x00	; 0
     67e:	80 91 ac 00 	lds	r24, 0x00AC
     682:	90 91 ad 00 	lds	r25, 0x00AD
     686:	82 0f       	add	r24, r18
     688:	93 1f       	adc	r25, r19
     68a:	01 97       	sbiw	r24, 0x01	; 1
     68c:	90 93 ad 00 	sts	0x00AD, r25
     690:	80 93 ac 00 	sts	0x00AC, r24
     694:	9f 91       	pop	r25
     696:	8f 91       	pop	r24
     698:	5f 91       	pop	r21
     69a:	4f 91       	pop	r20
     69c:	3f 91       	pop	r19
     69e:	2f 91       	pop	r18
     6a0:	0f 90       	pop	r0
     6a2:	0f be       	out	0x3f, r0	; 63
     6a4:	0f 90       	pop	r0
     6a6:	1f 90       	pop	r1
     6a8:	18 95       	reti

000006aa <uart_init>:
*	}
*  \endcode
*****************************************************************************/
void uart_init(void)
{
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	cd b7       	in	r28, 0x3d	; 61
     6b0:	de b7       	in	r29, 0x3e	; 62
	/* Baudrate einstellen ( Normaler Modus ) */
	UBRRH = (unsigned char) (UBRR_BAUD>>8);
     6b2:	10 92 40 00 	sts	0x0040, r1
	UBRRL = (unsigned char) UBRR_BAUD;	
     6b6:	85 e0       	ldi	r24, 0x05	; 5
     6b8:	80 93 29 00 	sts	0x0029, r24

	/* Aktivieren des Empfängers, des Senders und des "Daten empfangen"-Interrupts */
	UCSRB = (1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
     6bc:	88 e9       	ldi	r24, 0x98	; 152
     6be:	80 93 2a 00 	sts	0x002A, r24

	/* Einstellen des Datenformats: 8 Datenbits, 1 Stoppbit */
	UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
     6c2:	86 e8       	ldi	r24, 0x86	; 134
     6c4:	80 93 40 00 	sts	0x0040, r24
	
//	uart_puts("Uart wurde richtig initialisiert\n");
	
	// FIFOs für Eingabe initialisieren 
	fifo_init (&infifo,   inbuf, BUF_SIZE);
     6c8:	4a e0       	ldi	r20, 0x0A	; 10
     6ca:	6e ea       	ldi	r22, 0xAE	; 174
     6cc:	70 e0       	ldi	r23, 0x00	; 0
     6ce:	88 eb       	ldi	r24, 0xB8	; 184
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	0e 94 8a 06 	call	0xd14 <fifo_init>
     6d6:	df 91       	pop	r29
     6d8:	cf 91       	pop	r28
     6da:	08 95       	ret

000006dc <uart_putc>:
}


/****************************************************************************/
/*!
*  \brief
*  Senden eine einzelnes Zeichen über die serielle Schnittstelle
*  
*  \param[in]
*  c zu sendendes Zeichen
*
*  \return
*  nichts
*  
*  \par  Beispiel:
*  (Nur zur Demonstration der Parameter/Returnwerte)
*  \code
*  // Einzerlne Zeichen senden
*  uart_putc ('H');
*  uart_putc ('e');
*  uart_putc ('l');
*  uart_putc ('l');
*  uart_putc ('o');
*  \endcode
*****************************************************************************/
void uart_putc(char c)
{
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	cd b7       	in	r28, 0x3d	; 61
     6e2:	de b7       	in	r29, 0x3e	; 62
     6e4:	21 97       	sbiw	r28, 0x01	; 1
     6e6:	0f b6       	in	r0, 0x3f	; 63
     6e8:	f8 94       	cli
     6ea:	de bf       	out	0x3e, r29	; 62
     6ec:	0f be       	out	0x3f, r0	; 63
     6ee:	cd bf       	out	0x3d, r28	; 61
     6f0:	89 83       	std	Y+1, r24	; 0x01
	/* warten bis der Sendepuffer leer ist */
	while ( !( UCSRA & (1<<UDRE)) );
     6f2:	80 91 2b 00 	lds	r24, 0x002B
     6f6:	99 27       	eor	r25, r25
     6f8:	80 72       	andi	r24, 0x20	; 32
     6fa:	90 70       	andi	r25, 0x00	; 0
     6fc:	00 97       	sbiw	r24, 0x00	; 0
     6fe:	09 f4       	brne	.+2      	; 0x702 <uart_putc+0x26>
     700:	f8 cf       	rjmp	.-16     	; 0x6f2 <uart_putc+0x16>
	
	/* Zeichen senden */
	UDR = c;
     702:	89 81       	ldd	r24, Y+1	; 0x01
     704:	80 93 2c 00 	sts	0x002C, r24
     708:	21 96       	adiw	r28, 0x01	; 1
     70a:	0f b6       	in	r0, 0x3f	; 63
     70c:	f8 94       	cli
     70e:	de bf       	out	0x3e, r29	; 62
     710:	0f be       	out	0x3f, r0	; 63
     712:	cd bf       	out	0x3d, r28	; 61
     714:	df 91       	pop	r29
     716:	cf 91       	pop	r28
     718:	08 95       	ret

0000071a <uart_puts>:
}


/****************************************************************************/
/*!
*  \brief
*  Senden eines null-terminierten Strings
*  
*  \param[in]
*  s Pointer auf null-terminierten String
*
*  \return
*  nichts
*    
*  \par  Beispiel:
*  (Nur zur Demonstration der Parameter/Returnwerte)
*  \code
*  // Beispiel fuer uart_puts
*  uart_puts ("Hello World!\r\n");
*  \endcode
*****************************************************************************/
void uart_puts(char *s)
{
     71a:	cf 93       	push	r28
     71c:	df 93       	push	r29
     71e:	cd b7       	in	r28, 0x3d	; 61
     720:	de b7       	in	r29, 0x3e	; 62
     722:	22 97       	sbiw	r28, 0x02	; 2
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	9a 83       	std	Y+2, r25	; 0x02
     730:	89 83       	std	Y+1, r24	; 0x01
	while(*s) // so lange senden, bis das ende des Strings erreicht ist
     732:	e9 81       	ldd	r30, Y+1	; 0x01
     734:	fa 81       	ldd	r31, Y+2	; 0x02
     736:	80 81       	ld	r24, Z
     738:	88 23       	and	r24, r24
     73a:	49 f0       	breq	.+18     	; 0x74e <uart_puts+0x34>
	{
		uart_putc(*s++);
     73c:	e9 81       	ldd	r30, Y+1	; 0x01
     73e:	fa 81       	ldd	r31, Y+2	; 0x02
     740:	80 81       	ld	r24, Z
     742:	31 96       	adiw	r30, 0x01	; 1
     744:	fa 83       	std	Y+2, r31	; 0x02
     746:	e9 83       	std	Y+1, r30	; 0x01
     748:	0e 94 6e 03 	call	0x6dc <uart_putc>
     74c:	f2 cf       	rjmp	.-28     	; 0x732 <uart_puts+0x18>
     74e:	22 96       	adiw	r28, 0x02	; 2
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	f8 94       	cli
     754:	de bf       	out	0x3e, r29	; 62
     756:	0f be       	out	0x3f, r0	; 63
     758:	cd bf       	out	0x3d, r28	; 61
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <uart_puts_p>:
	}
}

/****************************************************************************/
/*!
*  \brief
*  Senden eines null-terminierten Strings der im Flash-Speicher steht
*  
*  \param[in]
*  text Pointer auf Flashadresse
*
*    
*  \par  Beispiel:
*  (Nur zur Demonstration der Parameter/Returnwerte)
*  \code
*  // Beispiel fuer uart_puts
*  uart_puts_p(PSTR("Hallo Herr Mustermann!\r\n"));
*  \endcode
*****************************************************************************/
void uart_puts_p(const char *text)
{
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	cd b7       	in	r28, 0x3d	; 61
     766:	de b7       	in	r29, 0x3e	; 62
     768:	26 97       	sbiw	r28, 0x06	; 6
     76a:	0f b6       	in	r0, 0x3f	; 63
     76c:	f8 94       	cli
     76e:	de bf       	out	0x3e, r29	; 62
     770:	0f be       	out	0x3f, r0	; 63
     772:	cd bf       	out	0x3d, r28	; 61
     774:	9a 83       	std	Y+2, r25	; 0x02
     776:	89 83       	std	Y+1, r24	; 0x01
    char Zeichen;
 
    while ((Zeichen = pgm_read_byte(text)))
     778:	89 81       	ldd	r24, Y+1	; 0x01
     77a:	9a 81       	ldd	r25, Y+2	; 0x02
     77c:	9d 83       	std	Y+5, r25	; 0x05
     77e:	8c 83       	std	Y+4, r24	; 0x04
     780:	ec 81       	ldd	r30, Y+4	; 0x04
     782:	fd 81       	ldd	r31, Y+5	; 0x05
     784:	84 91       	lpm	r24, Z
     786:	8e 83       	std	Y+6, r24	; 0x06
     788:	8e 81       	ldd	r24, Y+6	; 0x06
     78a:	8b 83       	std	Y+3, r24	; 0x03
     78c:	88 23       	and	r24, r24
     78e:	49 f0       	breq	.+18     	; 0x7a2 <uart_puts_p+0x42>
    {   /* so lange, wie mittels pgm_read_byte ein Zeichen vom Flash gelesen
           werden konnte, welches nicht das "String-Endezeichen" darstellt */
 
        /* Das gelesene Zeichen über die normalen Kanäle verschicken */
        uart_putc(Zeichen);
     790:	8b 81       	ldd	r24, Y+3	; 0x03
     792:	0e 94 6e 03 	call	0x6dc <uart_putc>
        text++;
     796:	89 81       	ldd	r24, Y+1	; 0x01
     798:	9a 81       	ldd	r25, Y+2	; 0x02
     79a:	01 96       	adiw	r24, 0x01	; 1
     79c:	9a 83       	std	Y+2, r25	; 0x02
     79e:	89 83       	std	Y+1, r24	; 0x01
     7a0:	eb cf       	rjmp	.-42     	; 0x778 <uart_puts_p+0x18>
     7a2:	26 96       	adiw	r28, 0x06	; 6
     7a4:	0f b6       	in	r0, 0x3f	; 63
     7a6:	f8 94       	cli
     7a8:	de bf       	out	0x3e, r29	; 62
     7aa:	0f be       	out	0x3f, r0	; 63
     7ac:	cd bf       	out	0x3d, r28	; 61
     7ae:	df 91       	pop	r29
     7b0:	cf 91       	pop	r28
     7b2:	08 95       	ret

000007b4 <uart_send>:
    }
}

/****************************************************************************/
/*!
*  \brief
*  Sendet die Anzahl der angegebenen DatenBytes.
*	
*  \param[in]
*  p Pointer des ersten Bytes
*  \param[in]
*  n Anzahl der zu sendenden Bytes
*
*  \return
*  nichts
*  
*****************************************************************************/
void uart_send(uint8_t *p, uint8_t n)
{
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
     7bc:	23 97       	sbiw	r28, 0x03	; 3
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	f8 94       	cli
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	9a 83       	std	Y+2, r25	; 0x02
     7ca:	89 83       	std	Y+1, r24	; 0x01
     7cc:	6b 83       	std	Y+3, r22	; 0x03
	while(n--)
     7ce:	8b 81       	ldd	r24, Y+3	; 0x03
     7d0:	81 50       	subi	r24, 0x01	; 1
     7d2:	8b 83       	std	Y+3, r24	; 0x03
     7d4:	8f 3f       	cpi	r24, 0xFF	; 255
     7d6:	49 f0       	breq	.+18     	; 0x7ea <uart_send+0x36>
	{
		uart_putc(*p++);
     7d8:	e9 81       	ldd	r30, Y+1	; 0x01
     7da:	fa 81       	ldd	r31, Y+2	; 0x02
     7dc:	80 81       	ld	r24, Z
     7de:	31 96       	adiw	r30, 0x01	; 1
     7e0:	fa 83       	std	Y+2, r31	; 0x02
     7e2:	e9 83       	std	Y+1, r30	; 0x01
     7e4:	0e 94 6e 03 	call	0x6dc <uart_putc>
     7e8:	f2 cf       	rjmp	.-28     	; 0x7ce <uart_send+0x1a>
     7ea:	23 96       	adiw	r28, 0x03	; 3
     7ec:	0f b6       	in	r0, 0x3f	; 63
     7ee:	f8 94       	cli
     7f0:	de bf       	out	0x3e, r29	; 62
     7f2:	0f be       	out	0x3f, r0	; 63
     7f4:	cd bf       	out	0x3d, r28	; 61
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	08 95       	ret

000007fc <uart_puti>:
	}
}


/****************************************************************************/
/*!
*  \brief
*  Ausgabe eines Integer Wertes als String ueber die serielle Schnittstelle.
*
*  \param[in]
*  i Auszugebender Integer Wert (16Bit)
*  
*  \return
*  nichts
*
*  \par  Beispiel:
*  (Nur zur Demonstration der Parameter/Returnwerte)
*  \code
*  // Beispiel ausgabe eines Wertes
*  uart_puti( wert[0] );
*  uart_puts("\r\n");
*  \endcode
*****************************************************************************/
void uart_puti(uint16_t i)
{
     7fc:	cf 93       	push	r28
     7fe:	df 93       	push	r29
     800:	cd b7       	in	r28, 0x3d	; 61
     802:	de b7       	in	r29, 0x3e	; 62
     804:	29 97       	sbiw	r28, 0x09	; 9
     806:	0f b6       	in	r0, 0x3f	; 63
     808:	f8 94       	cli
     80a:	de bf       	out	0x3e, r29	; 62
     80c:	0f be       	out	0x3f, r0	; 63
     80e:	cd bf       	out	0x3d, r28	; 61
     810:	9a 83       	std	Y+2, r25	; 0x02
     812:	89 83       	std	Y+1, r24	; 0x01
	unsigned char s[7];	// "-12345"
	
	/* Wandeln eines Integers in einen String */
	itoa(i, s, 10);		
     814:	ce 01       	movw	r24, r28
     816:	03 96       	adiw	r24, 0x03	; 3
     818:	4a e0       	ldi	r20, 0x0A	; 10
     81a:	50 e0       	ldi	r21, 0x00	; 0
     81c:	bc 01       	movw	r22, r24
     81e:	89 81       	ldd	r24, Y+1	; 0x01
     820:	9a 81       	ldd	r25, Y+2	; 0x02
     822:	0e 94 6a 09 	call	0x12d4 <itoa>
	/* String versenden */
	uart_puts(s);			
     826:	ce 01       	movw	r24, r28
     828:	03 96       	adiw	r24, 0x03	; 3
     82a:	0e 94 8d 03 	call	0x71a <uart_puts>
     82e:	29 96       	adiw	r28, 0x09	; 9
     830:	0f b6       	in	r0, 0x3f	; 63
     832:	f8 94       	cli
     834:	de bf       	out	0x3e, r29	; 62
     836:	0f be       	out	0x3f, r0	; 63
     838:	cd bf       	out	0x3d, r28	; 61
     83a:	df 91       	pop	r29
     83c:	cf 91       	pop	r28
     83e:	08 95       	ret

00000840 <uart_printtime>:
}

/**************************************************************************/
/*! 
* \brief gibt die aktuelle Systemzeit im Format Min:Sec:mSec
*		über die UART verbindung aus\n
*
***************************************************************************/
void uart_printtime(void)
{
     840:	ef 92       	push	r14
     842:	ff 92       	push	r15
     844:	0f 93       	push	r16
     846:	1f 93       	push	r17
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	cd b7       	in	r28, 0x3d	; 61
     84e:	de b7       	in	r29, 0x3e	; 62
     850:	2d 97       	sbiw	r28, 0x0d	; 13
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	de bf       	out	0x3e, r29	; 62
     858:	0f be       	out	0x3f, r0	; 63
     85a:	cd bf       	out	0x3d, r28	; 61
	uint32_t ms;
	uint32_t s;
	uint32_t min;
	uint8_t std;
	
	ms = Gettime();
     85c:	0e 94 bc 05 	call	0xb78 <Gettime>
     860:	dc 01       	movw	r26, r24
     862:	cb 01       	movw	r24, r22
     864:	89 83       	std	Y+1, r24	; 0x01
     866:	9a 83       	std	Y+2, r25	; 0x02
     868:	ab 83       	std	Y+3, r26	; 0x03
     86a:	bc 83       	std	Y+4, r27	; 0x04
	if(ms == 0)
     86c:	89 81       	ldd	r24, Y+1	; 0x01
     86e:	9a 81       	ldd	r25, Y+2	; 0x02
     870:	ab 81       	ldd	r26, Y+3	; 0x03
     872:	bc 81       	ldd	r27, Y+4	; 0x04
     874:	00 97       	sbiw	r24, 0x00	; 0
     876:	a1 05       	cpc	r26, r1
     878:	b1 05       	cpc	r27, r1
     87a:	09 f4       	brne	.+2      	; 0x87e <uart_printtime+0x3e>
		return;
     87c:	02 c1       	rjmp	.+516    	; 0xa82 <uart_printtime+0x242>
		
	s = ms/1000;
     87e:	89 81       	ldd	r24, Y+1	; 0x01
     880:	9a 81       	ldd	r25, Y+2	; 0x02
     882:	ab 81       	ldd	r26, Y+3	; 0x03
     884:	bc 81       	ldd	r27, Y+4	; 0x04
     886:	28 ee       	ldi	r18, 0xE8	; 232
     888:	33 e0       	ldi	r19, 0x03	; 3
     88a:	40 e0       	ldi	r20, 0x00	; 0
     88c:	50 e0       	ldi	r21, 0x00	; 0
     88e:	bc 01       	movw	r22, r24
     890:	cd 01       	movw	r24, r26
     892:	0e 94 ba 09 	call	0x1374 <__udivmodsi4>
     896:	da 01       	movw	r26, r20
     898:	c9 01       	movw	r24, r18
     89a:	8d 83       	std	Y+5, r24	; 0x05
     89c:	9e 83       	std	Y+6, r25	; 0x06
     89e:	af 83       	std	Y+7, r26	; 0x07
     8a0:	b8 87       	std	Y+8, r27	; 0x08
	min = s / 60;
     8a2:	8d 81       	ldd	r24, Y+5	; 0x05
     8a4:	9e 81       	ldd	r25, Y+6	; 0x06
     8a6:	af 81       	ldd	r26, Y+7	; 0x07
     8a8:	b8 85       	ldd	r27, Y+8	; 0x08
     8aa:	2c e3       	ldi	r18, 0x3C	; 60
     8ac:	30 e0       	ldi	r19, 0x00	; 0
     8ae:	40 e0       	ldi	r20, 0x00	; 0
     8b0:	50 e0       	ldi	r21, 0x00	; 0
     8b2:	bc 01       	movw	r22, r24
     8b4:	cd 01       	movw	r24, r26
     8b6:	0e 94 ba 09 	call	0x1374 <__udivmodsi4>
     8ba:	da 01       	movw	r26, r20
     8bc:	c9 01       	movw	r24, r18
     8be:	89 87       	std	Y+9, r24	; 0x09
     8c0:	9a 87       	std	Y+10, r25	; 0x0a
     8c2:	ab 87       	std	Y+11, r26	; 0x0b
     8c4:	bc 87       	std	Y+12, r27	; 0x0c
	std = min / 60;
     8c6:	89 85       	ldd	r24, Y+9	; 0x09
     8c8:	9a 85       	ldd	r25, Y+10	; 0x0a
     8ca:	ab 85       	ldd	r26, Y+11	; 0x0b
     8cc:	bc 85       	ldd	r27, Y+12	; 0x0c
     8ce:	2c e3       	ldi	r18, 0x3C	; 60
     8d0:	30 e0       	ldi	r19, 0x00	; 0
     8d2:	40 e0       	ldi	r20, 0x00	; 0
     8d4:	50 e0       	ldi	r21, 0x00	; 0
     8d6:	bc 01       	movw	r22, r24
     8d8:	cd 01       	movw	r24, r26
     8da:	0e 94 ba 09 	call	0x1374 <__udivmodsi4>
     8de:	da 01       	movw	r26, r20
     8e0:	c9 01       	movw	r24, r18
     8e2:	8d 87       	std	Y+13, r24	; 0x0d
	min = min - (std*60);
     8e4:	9d 85       	ldd	r25, Y+13	; 0x0d
     8e6:	8c e3       	ldi	r24, 0x3C	; 60
     8e8:	98 9f       	mul	r25, r24
     8ea:	c0 01       	movw	r24, r0
     8ec:	11 24       	eor	r1, r1
     8ee:	9c 01       	movw	r18, r24
     8f0:	44 27       	eor	r20, r20
     8f2:	37 fd       	sbrc	r19, 7
     8f4:	40 95       	com	r20
     8f6:	54 2f       	mov	r21, r20
     8f8:	89 85       	ldd	r24, Y+9	; 0x09
     8fa:	9a 85       	ldd	r25, Y+10	; 0x0a
     8fc:	ab 85       	ldd	r26, Y+11	; 0x0b
     8fe:	bc 85       	ldd	r27, Y+12	; 0x0c
     900:	82 1b       	sub	r24, r18
     902:	93 0b       	sbc	r25, r19
     904:	a4 0b       	sbc	r26, r20
     906:	b5 0b       	sbc	r27, r21
     908:	89 87       	std	Y+9, r24	; 0x09
     90a:	9a 87       	std	Y+10, r25	; 0x0a
     90c:	ab 87       	std	Y+11, r26	; 0x0b
     90e:	bc 87       	std	Y+12, r27	; 0x0c
	s = s - ((min*60)+(std*60*60));
     910:	89 85       	ldd	r24, Y+9	; 0x09
     912:	9a 85       	ldd	r25, Y+10	; 0x0a
     914:	ab 85       	ldd	r26, Y+11	; 0x0b
     916:	bc 85       	ldd	r27, Y+12	; 0x0c
     918:	2c e3       	ldi	r18, 0x3C	; 60
     91a:	30 e0       	ldi	r19, 0x00	; 0
     91c:	40 e0       	ldi	r20, 0x00	; 0
     91e:	50 e0       	ldi	r21, 0x00	; 0
     920:	bc 01       	movw	r22, r24
     922:	cd 01       	movw	r24, r26
     924:	0e 94 9b 09 	call	0x1336 <__mulsi3>
     928:	ab 01       	movw	r20, r22
     92a:	bc 01       	movw	r22, r24
     92c:	8d 85       	ldd	r24, Y+13	; 0x0d
     92e:	28 2f       	mov	r18, r24
     930:	33 27       	eor	r19, r19
     932:	80 e1       	ldi	r24, 0x10	; 16
     934:	9e e0       	ldi	r25, 0x0E	; 14
     936:	28 9f       	mul	r18, r24
     938:	f0 01       	movw	r30, r0
     93a:	29 9f       	mul	r18, r25
     93c:	f0 0d       	add	r31, r0
     93e:	38 9f       	mul	r19, r24
     940:	f0 0d       	add	r31, r0
     942:	11 24       	eor	r1, r1
     944:	cf 01       	movw	r24, r30
     946:	aa 27       	eor	r26, r26
     948:	97 fd       	sbrc	r25, 7
     94a:	a0 95       	com	r26
     94c:	ba 2f       	mov	r27, r26
     94e:	9a 01       	movw	r18, r20
     950:	ab 01       	movw	r20, r22
     952:	28 0f       	add	r18, r24
     954:	39 1f       	adc	r19, r25
     956:	4a 1f       	adc	r20, r26
     958:	5b 1f       	adc	r21, r27
     95a:	8d 81       	ldd	r24, Y+5	; 0x05
     95c:	9e 81       	ldd	r25, Y+6	; 0x06
     95e:	af 81       	ldd	r26, Y+7	; 0x07
     960:	b8 85       	ldd	r27, Y+8	; 0x08
     962:	82 1b       	sub	r24, r18
     964:	93 0b       	sbc	r25, r19
     966:	a4 0b       	sbc	r26, r20
     968:	b5 0b       	sbc	r27, r21
     96a:	8d 83       	std	Y+5, r24	; 0x05
     96c:	9e 83       	std	Y+6, r25	; 0x06
     96e:	af 83       	std	Y+7, r26	; 0x07
     970:	b8 87       	std	Y+8, r27	; 0x08
	ms = ms - ((s*1000)+(min*60*1000)+(std*60*60*1000));
     972:	8d 81       	ldd	r24, Y+5	; 0x05
     974:	9e 81       	ldd	r25, Y+6	; 0x06
     976:	af 81       	ldd	r26, Y+7	; 0x07
     978:	b8 85       	ldd	r27, Y+8	; 0x08
     97a:	28 ee       	ldi	r18, 0xE8	; 232
     97c:	33 e0       	ldi	r19, 0x03	; 3
     97e:	40 e0       	ldi	r20, 0x00	; 0
     980:	50 e0       	ldi	r21, 0x00	; 0
     982:	bc 01       	movw	r22, r24
     984:	cd 01       	movw	r24, r26
     986:	0e 94 9b 09 	call	0x1336 <__mulsi3>
     98a:	7b 01       	movw	r14, r22
     98c:	8c 01       	movw	r16, r24
     98e:	89 85       	ldd	r24, Y+9	; 0x09
     990:	9a 85       	ldd	r25, Y+10	; 0x0a
     992:	ab 85       	ldd	r26, Y+11	; 0x0b
     994:	bc 85       	ldd	r27, Y+12	; 0x0c
     996:	20 e6       	ldi	r18, 0x60	; 96
     998:	3a ee       	ldi	r19, 0xEA	; 234
     99a:	40 e0       	ldi	r20, 0x00	; 0
     99c:	50 e0       	ldi	r21, 0x00	; 0
     99e:	bc 01       	movw	r22, r24
     9a0:	cd 01       	movw	r24, r26
     9a2:	0e 94 9b 09 	call	0x1336 <__mulsi3>
     9a6:	dc 01       	movw	r26, r24
     9a8:	cb 01       	movw	r24, r22
     9aa:	b8 01       	movw	r22, r16
     9ac:	a7 01       	movw	r20, r14
     9ae:	48 0f       	add	r20, r24
     9b0:	59 1f       	adc	r21, r25
     9b2:	6a 1f       	adc	r22, r26
     9b4:	7b 1f       	adc	r23, r27
     9b6:	8d 85       	ldd	r24, Y+13	; 0x0d
     9b8:	28 2f       	mov	r18, r24
     9ba:	33 27       	eor	r19, r19
     9bc:	80 e8       	ldi	r24, 0x80	; 128
     9be:	9e ee       	ldi	r25, 0xEE	; 238
     9c0:	28 9f       	mul	r18, r24
     9c2:	f0 01       	movw	r30, r0
     9c4:	29 9f       	mul	r18, r25
     9c6:	f0 0d       	add	r31, r0
     9c8:	38 9f       	mul	r19, r24
     9ca:	f0 0d       	add	r31, r0
     9cc:	11 24       	eor	r1, r1
     9ce:	cf 01       	movw	r24, r30
     9d0:	aa 27       	eor	r26, r26
     9d2:	97 fd       	sbrc	r25, 7
     9d4:	a0 95       	com	r26
     9d6:	ba 2f       	mov	r27, r26
     9d8:	9a 01       	movw	r18, r20
     9da:	ab 01       	movw	r20, r22
     9dc:	28 0f       	add	r18, r24
     9de:	39 1f       	adc	r19, r25
     9e0:	4a 1f       	adc	r20, r26
     9e2:	5b 1f       	adc	r21, r27
     9e4:	89 81       	ldd	r24, Y+1	; 0x01
     9e6:	9a 81       	ldd	r25, Y+2	; 0x02
     9e8:	ab 81       	ldd	r26, Y+3	; 0x03
     9ea:	bc 81       	ldd	r27, Y+4	; 0x04
     9ec:	82 1b       	sub	r24, r18
     9ee:	93 0b       	sbc	r25, r19
     9f0:	a4 0b       	sbc	r26, r20
     9f2:	b5 0b       	sbc	r27, r21
     9f4:	89 83       	std	Y+1, r24	; 0x01
     9f6:	9a 83       	std	Y+2, r25	; 0x02
     9f8:	ab 83       	std	Y+3, r26	; 0x03
     9fa:	bc 83       	std	Y+4, r27	; 0x04
	if(std<10)
     9fc:	8d 85       	ldd	r24, Y+13	; 0x0d
     9fe:	8a 30       	cpi	r24, 0x0A	; 10
     a00:	18 f4       	brcc	.+6      	; 0xa08 <uart_printtime+0x1c8>
		uart_putc('0');
     a02:	80 e3       	ldi	r24, 0x30	; 48
     a04:	0e 94 6e 03 	call	0x6dc <uart_putc>
	uart_puti(std);
     a08:	8d 85       	ldd	r24, Y+13	; 0x0d
     a0a:	99 27       	eor	r25, r25
     a0c:	0e 94 fe 03 	call	0x7fc <uart_puti>
	uart_putc(':');
     a10:	8a e3       	ldi	r24, 0x3A	; 58
     a12:	0e 94 6e 03 	call	0x6dc <uart_putc>
	if(min<10)
     a16:	89 85       	ldd	r24, Y+9	; 0x09
     a18:	9a 85       	ldd	r25, Y+10	; 0x0a
     a1a:	ab 85       	ldd	r26, Y+11	; 0x0b
     a1c:	bc 85       	ldd	r27, Y+12	; 0x0c
     a1e:	8a 30       	cpi	r24, 0x0A	; 10
     a20:	91 05       	cpc	r25, r1
     a22:	a1 05       	cpc	r26, r1
     a24:	b1 05       	cpc	r27, r1
     a26:	18 f4       	brcc	.+6      	; 0xa2e <uart_printtime+0x1ee>
		uart_putc('0');
     a28:	80 e3       	ldi	r24, 0x30	; 48
     a2a:	0e 94 6e 03 	call	0x6dc <uart_putc>
	uart_puti(min);
     a2e:	89 85       	ldd	r24, Y+9	; 0x09
     a30:	9a 85       	ldd	r25, Y+10	; 0x0a
     a32:	0e 94 fe 03 	call	0x7fc <uart_puti>
	uart_putc(':');
     a36:	8a e3       	ldi	r24, 0x3A	; 58
     a38:	0e 94 6e 03 	call	0x6dc <uart_putc>
	if(s<10)
     a3c:	8d 81       	ldd	r24, Y+5	; 0x05
     a3e:	9e 81       	ldd	r25, Y+6	; 0x06
     a40:	af 81       	ldd	r26, Y+7	; 0x07
     a42:	b8 85       	ldd	r27, Y+8	; 0x08
     a44:	8a 30       	cpi	r24, 0x0A	; 10
     a46:	91 05       	cpc	r25, r1
     a48:	a1 05       	cpc	r26, r1
     a4a:	b1 05       	cpc	r27, r1
     a4c:	18 f4       	brcc	.+6      	; 0xa54 <uart_printtime+0x214>
		uart_putc('0');
     a4e:	80 e3       	ldi	r24, 0x30	; 48
     a50:	0e 94 6e 03 	call	0x6dc <uart_putc>
	uart_puti(s);
     a54:	8d 81       	ldd	r24, Y+5	; 0x05
     a56:	9e 81       	ldd	r25, Y+6	; 0x06
     a58:	0e 94 fe 03 	call	0x7fc <uart_puti>
	uart_putc(':');
     a5c:	8a e3       	ldi	r24, 0x3A	; 58
     a5e:	0e 94 6e 03 	call	0x6dc <uart_putc>
//	if(ms<100)
//		uart_putc('0');
//	if(ms<10 && ms!=0)
//		uart_putc('0');
//	uart_puti(ms);
	uart_puti(ms/100);
     a62:	89 81       	ldd	r24, Y+1	; 0x01
     a64:	9a 81       	ldd	r25, Y+2	; 0x02
     a66:	ab 81       	ldd	r26, Y+3	; 0x03
     a68:	bc 81       	ldd	r27, Y+4	; 0x04
     a6a:	24 e6       	ldi	r18, 0x64	; 100
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	40 e0       	ldi	r20, 0x00	; 0
     a70:	50 e0       	ldi	r21, 0x00	; 0
     a72:	bc 01       	movw	r22, r24
     a74:	cd 01       	movw	r24, r26
     a76:	0e 94 ba 09 	call	0x1374 <__udivmodsi4>
     a7a:	da 01       	movw	r26, r20
     a7c:	c9 01       	movw	r24, r18
     a7e:	0e 94 fe 03 	call	0x7fc <uart_puti>
     a82:	2d 96       	adiw	r28, 0x0d	; 13
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	f8 94       	cli
     a88:	de bf       	out	0x3e, r29	; 62
     a8a:	0f be       	out	0x3f, r0	; 63
     a8c:	cd bf       	out	0x3d, r28	; 61
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	1f 91       	pop	r17
     a94:	0f 91       	pop	r16
     a96:	ff 90       	pop	r15
     a98:	ef 90       	pop	r14
     a9a:	08 95       	ret

00000a9c <uart_getc>:
}

/****************************************************************************/
/*!
*  \brief Einzelnes Zeichen empfangen
*
*  \return
*	empfangenes Zeichen, ist der Empfangspuffer leer liefert die Funktion -1 zurück
*
*****************************************************************************/
int8_t uart_getc(void)
{
     a9c:	cf 93       	push	r28
     a9e:	df 93       	push	r29
     aa0:	cd b7       	in	r28, 0x3d	; 61
     aa2:	de b7       	in	r29, 0x3e	; 62
     aa4:	23 97       	sbiw	r28, 0x03	; 3
     aa6:	0f b6       	in	r0, 0x3f	; 63
     aa8:	f8 94       	cli
     aaa:	de bf       	out	0x3e, r29	; 62
     aac:	0f be       	out	0x3f, r0	; 63
     aae:	cd bf       	out	0x3d, r28	; 61
	uint8_t data;
	
	if (fifo_get(&infifo, &data)==0){
     ab0:	be 01       	movw	r22, r28
     ab2:	6f 5f       	subi	r22, 0xFF	; 255
     ab4:	7f 4f       	sbci	r23, 0xFF	; 255
     ab6:	88 eb       	ldi	r24, 0xB8	; 184
     ab8:	90 e0       	ldi	r25, 0x00	; 0
     aba:	0e 94 b1 06 	call	0xd62 <fifo_get>
     abe:	88 23       	and	r24, r24
     ac0:	39 f4       	brne	.+14     	; 0xad0 <uart_getc+0x34>
		return data;
     ac2:	89 81       	ldd	r24, Y+1	; 0x01
     ac4:	99 27       	eor	r25, r25
     ac6:	87 fd       	sbrc	r24, 7
     ac8:	90 95       	com	r25
     aca:	9b 83       	std	Y+3, r25	; 0x03
     acc:	8a 83       	std	Y+2, r24	; 0x02
     ace:	04 c0       	rjmp	.+8      	; 0xad8 <uart_getc+0x3c>
	} else {
		return -1;
     ad0:	8f ef       	ldi	r24, 0xFF	; 255
     ad2:	9f ef       	ldi	r25, 0xFF	; 255
     ad4:	9b 83       	std	Y+3, r25	; 0x03
     ad6:	8a 83       	std	Y+2, r24	; 0x02
	}
}
     ad8:	8a 81       	ldd	r24, Y+2	; 0x02
     ada:	9b 81       	ldd	r25, Y+3	; 0x03
     adc:	23 96       	adiw	r28, 0x03	; 3
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	de bf       	out	0x3e, r29	; 62
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	cd bf       	out	0x3d, r28	; 61
     ae8:	df 91       	pop	r29
     aea:	cf 91       	pop	r28
     aec:	08 95       	ret

00000aee <__vector_11>:


/****************************************************************************/
/*!
*  \brief
*  Interrupt wird ausgelöst sobald neue Daten im USART-Empfangspuffer liegen.
*  
*  Der Interrupt sendet das empfangene Zeichen gleich wieder zurück.\n
*  Als \c echo Funktion zur Fehlersuche.\n
*  
*****************************************************************************/
ISR(USART_RXC_vect)
{
     aee:	1f 92       	push	r1
     af0:	0f 92       	push	r0
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	0f 92       	push	r0
     af6:	11 24       	eor	r1, r1
     af8:	2f 93       	push	r18
     afa:	3f 93       	push	r19
     afc:	4f 93       	push	r20
     afe:	5f 93       	push	r21
     b00:	6f 93       	push	r22
     b02:	7f 93       	push	r23
     b04:	8f 93       	push	r24
     b06:	9f 93       	push	r25
     b08:	af 93       	push	r26
     b0a:	bf 93       	push	r27
     b0c:	ef 93       	push	r30
     b0e:	ff 93       	push	r31
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	cd b7       	in	r28, 0x3d	; 61
     b16:	de b7       	in	r29, 0x3e	; 62
     b18:	21 97       	sbiw	r28, 0x01	; 1
     b1a:	de bf       	out	0x3e, r29	; 62
     b1c:	cd bf       	out	0x3d, r28	; 61
	 
	unsigned char buffer;

	/* Daten aus dem Puffer lesen */
	buffer = UDR;
     b1e:	80 91 2c 00 	lds	r24, 0x002C
     b22:	89 83       	std	Y+1, r24	; 0x01
	fifo_put(&infifo, buffer);
     b24:	69 81       	ldd	r22, Y+1	; 0x01
     b26:	88 eb       	ldi	r24, 0xB8	; 184
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	0e 94 94 06 	call	0xd28 <fifo_put>

	/* warten bis der Sendepuffer leer ist */
	while ( !( UCSRA & (1<<UDRE)) );
     b2e:	80 91 2b 00 	lds	r24, 0x002B
     b32:	99 27       	eor	r25, r25
     b34:	80 72       	andi	r24, 0x20	; 32
     b36:	90 70       	andi	r25, 0x00	; 0
     b38:	00 97       	sbiw	r24, 0x00	; 0
     b3a:	09 f4       	brne	.+2      	; 0xb3e <__vector_11+0x50>
     b3c:	f8 cf       	rjmp	.-16     	; 0xb2e <__vector_11+0x40>
     b3e:	21 96       	adiw	r28, 0x01	; 1
     b40:	f8 94       	cli
     b42:	de bf       	out	0x3e, r29	; 62
     b44:	cd bf       	out	0x3d, r28	; 61
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	ff 91       	pop	r31
     b4c:	ef 91       	pop	r30
     b4e:	bf 91       	pop	r27
     b50:	af 91       	pop	r26
     b52:	9f 91       	pop	r25
     b54:	8f 91       	pop	r24
     b56:	7f 91       	pop	r23
     b58:	6f 91       	pop	r22
     b5a:	5f 91       	pop	r21
     b5c:	4f 91       	pop	r20
     b5e:	3f 91       	pop	r19
     b60:	2f 91       	pop	r18
     b62:	0f 90       	pop	r0
     b64:	0f be       	out	0x3f, r0	; 63
     b66:	0f 90       	pop	r0
     b68:	1f 90       	pop	r1
     b6a:	18 95       	reti

00000b6c <timer2_init>:
*****************************************************************************/
void timer2_init(void)
{
	/* Timer2 auf 36 kHz eingestellt. */
	TCCR2 = (1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21) | (1 << CS21);
     b6c:	8a e7       	ldi	r24, 0x7A	; 122
     b6e:	85 bd       	out	0x25, r24	; 37

	/* Interrupts für Timer2 aktivieren */	
	TIMSK |= (1<<TOIE2);
     b70:	89 b7       	in	r24, 0x39	; 57
     b72:	80 64       	ori	r24, 0x40	; 64
     b74:	89 bf       	out	0x39, r24	; 57
     b76:	08 95       	ret

00000b78 <Gettime>:
}	

/****************************************************************************/
/*!
  \brief
  Gibt die aktuelle Zeit in ms zurueck.

  Die vergangene Zeit seit dem Einschalten\n
  Genauer: nachdem der Interrupt Timer2 aktiviert wurde.\n

  \param
  keine

  \return
  Einschaltzeit in Millisekunden (Bereich: unsigned long 0..286331153)\n
  Das sind ca. 79.5 Stunden. Diese Zeitangabe reicht bis der Accu leer ist.

  \par  Beispiel:
  (Nur zur Demonstration der Parameter/Returnwerte)
  \code
  // Alle 500 ms die Front-LED umschalten.
  unsigned long zeit;
  unsigned char on_off = TRUE;

  zeit = Gettime ();
  while (1)
  {
    if (Gettime () > zeit + 500)
    {
      zeit = Gettime ();
      FrontLED (on_off);
      on_off ^= 1;
    }
  }
  \endcode
*****************************************************************************/
unsigned long Gettime (void)
{
  return ((timebase * 256) + count36kHz) / 36;
     b78:	80 91 a6 00 	lds	r24, 0x00A6
     b7c:	90 91 a7 00 	lds	r25, 0x00A7
     b80:	a0 91 a8 00 	lds	r26, 0x00A8
     b84:	b0 91 a9 00 	lds	r27, 0x00A9
     b88:	ba 2f       	mov	r27, r26
     b8a:	a9 2f       	mov	r26, r25
     b8c:	98 2f       	mov	r25, r24
     b8e:	88 27       	eor	r24, r24
     b90:	20 91 a5 00 	lds	r18, 0x00A5
     b94:	82 0f       	add	r24, r18
     b96:	91 1d       	adc	r25, r1
     b98:	a1 1d       	adc	r26, r1
     b9a:	b1 1d       	adc	r27, r1
     b9c:	bc 01       	movw	r22, r24
     b9e:	cd 01       	movw	r24, r26
     ba0:	24 e2       	ldi	r18, 0x24	; 36
     ba2:	30 e0       	ldi	r19, 0x00	; 0
     ba4:	40 e0       	ldi	r20, 0x00	; 0
     ba6:	50 e0       	ldi	r21, 0x00	; 0
     ba8:	0e 94 ba 09 	call	0x1374 <__udivmodsi4>
}
     bac:	ca 01       	movw	r24, r20
     bae:	b9 01       	movw	r22, r18
     bb0:	08 95       	ret

00000bb2 <sleep>:

/****************************************************************************/
/*!
  \brief
  Wartefunktion.

  Die maximale Wartezeit betraegt 7ms. Fuer laengere Wartezeiten siehe Msleep().\n
  Diese Funktion nutzt den Timer 2-Interrupt um ein 'zeitgefuehl' zu erhalten.\n
  Der Interrupt wird mit 36 kHz, durch die Init()-Funktion initialisiert,\n
  aufgerufen und zaehlt dort die globale Variablen \b count36kHz weiter.\n
  Diese Funktion nutzt diesen Zaehler und berechnet daraus mit dem uebergeben\n
  Parameter den Zeitpunkt wann die Pausenzeit erreicht ist, Danach bricht sie\n
  ab, und im Hauptprogramm ist eben eine Wartezeit eingelegt worden.

  \param[in]
  time36kHz Wartezeit x/36kHz (sec)

  \return
  nichts

  \par  Beispiel:
  (Nur zur Demonstration der Parameter/Returnwerte)
  \code
  // 1 Millisekunde warten
  Sleep (36);
  \endcode
*****************************************************************************/
void sleep (
  unsigned char time36kHz)
{
  unsigned char ziel = (time36kHz + count36kHz) & 0x00FF;
     bb2:	90 91 a5 00 	lds	r25, 0x00A5
     bb6:	98 0f       	add	r25, r24

  while (count36kHz != ziel)
     bb8:	80 91 a5 00 	lds	r24, 0x00A5
     bbc:	89 17       	cp	r24, r25
     bbe:	e1 f7       	brne	.-8      	; 0xbb8 <sleep+0x6>
     bc0:	08 95       	ret

00000bc2 <msleep>:
    ;
}



/****************************************************************************/
/*!
  \brief
  Wartefunktion in ms.

  Diese Funktion nutzt die Sleep()-Funktion um mit dem uebergeben Parameter\n
  Pausen in ms-Einheiten zu erhalten.

  \param [in]
  dauer Wartezeit in Millisekunden.

  \return
  nichts

  \par  Beispiel:
  (Nur zur Demonstration der Parameter/Returnwerte)
  \code
  // 1.5 Sekunde warten
  Msleep (1500);
  \endcode
*****************************************************************************/
void msleep (int dauer)
{
     bc2:	0f 93       	push	r16
     bc4:	1f 93       	push	r17
     bc6:	cf 93       	push	r28
     bc8:	df 93       	push	r29
     bca:	8c 01       	movw	r16, r24
  int z;
  for (z = 0; z < dauer; z++)	// z-mal ..
     bcc:	c0 e0       	ldi	r28, 0x00	; 0
     bce:	d0 e0       	ldi	r29, 0x00	; 0
     bd0:	c8 17       	cp	r28, r24
     bd2:	d9 07       	cpc	r29, r25
     bd4:	3c f4       	brge	.+14     	; 0xbe4 <msleep+0x22>
    sleep (36);					// ..eine ms warten
     bd6:	84 e2       	ldi	r24, 0x24	; 36
     bd8:	0e 94 d9 05 	call	0xbb2 <sleep>
     bdc:	21 96       	adiw	r28, 0x01	; 1
     bde:	c0 17       	cp	r28, r16
     be0:	d1 07       	cpc	r29, r17
     be2:	cc f3       	brlt	.-14     	; 0xbd6 <msleep+0x14>
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	1f 91       	pop	r17
     bea:	0f 91       	pop	r16
     bec:	08 95       	ret

00000bee <__vector_4>:
}

/****************************************************************************/
/*!
  \brief
  Interrupt-Funktion fuer Timer-2-Ueberlauf.

  \param
  keine

  \return
  nichts

  \see
  count36kHz, timebase

  \par
  Der zum Timer gehoerende Zaehler TCNT2 wird so justiert, dass damit die\n
  gewuenschten 36 kHz erreicht werden.\n
  Fuer die Zeitfunktionen werden die globalen Variablen count36kHz und\n
  timebase hochgezaehlt.
*****************************************************************************/
ISR(TIMER2_OVF_vect) /* veraltet: SIGNAL(SIG_OVERFLOW1) */
{
     bee:	1f 92       	push	r1
     bf0:	0f 92       	push	r0
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	0f 92       	push	r0
     bf6:	11 24       	eor	r1, r1
     bf8:	8f 93       	push	r24
     bfa:	9f 93       	push	r25
     bfc:	af 93       	push	r26
     bfe:	bf 93       	push	r27
    /* erhöht den Wert des Timers um Ihn alle 36kHz überlaufen zu lassen */
	TCNT2 += 0xD7;
     c00:	84 b5       	in	r24, 0x24	; 36
     c02:	89 52       	subi	r24, 0x29	; 41
     c04:	84 bd       	out	0x24, r24	; 36
	
	/* Globalen counter erhöhen */
	count36kHz++;
     c06:	80 91 a5 00 	lds	r24, 0x00A5
     c0a:	8f 5f       	subi	r24, 0xFF	; 255
     c0c:	80 93 a5 00 	sts	0x00A5, r24
	
	/* beim Überlauf globale Zeit erhöhen */
	if(!count36kHz){
     c10:	80 91 a5 00 	lds	r24, 0x00A5
     c14:	88 23       	and	r24, r24
     c16:	99 f4       	brne	.+38     	; 0xc3e <__vector_4+0x50>
		timebase++;
     c18:	80 91 a6 00 	lds	r24, 0x00A6
     c1c:	90 91 a7 00 	lds	r25, 0x00A7
     c20:	a0 91 a8 00 	lds	r26, 0x00A8
     c24:	b0 91 a9 00 	lds	r27, 0x00A9
     c28:	01 96       	adiw	r24, 0x01	; 1
     c2a:	a1 1d       	adc	r26, r1
     c2c:	b1 1d       	adc	r27, r1
     c2e:	80 93 a6 00 	sts	0x00A6, r24
     c32:	90 93 a7 00 	sts	0x00A7, r25
     c36:	a0 93 a8 00 	sts	0x00A8, r26
     c3a:	b0 93 a9 00 	sts	0x00A9, r27
     c3e:	bf 91       	pop	r27
     c40:	af 91       	pop	r26
     c42:	9f 91       	pop	r25
     c44:	8f 91       	pop	r24
     c46:	0f 90       	pop	r0
     c48:	0f be       	out	0x3f, r0	; 63
     c4a:	0f 90       	pop	r0
     c4c:	1f 90       	pop	r1
     c4e:	18 95       	reti

00000c50 <motor_dir>:
*	right_dir Drehrichtung des rechten Motors
***************************************************************************/
void motor_dir(uint8_t left_dir, uint8_t right_dir)
{
	switch (left_dir)
     c50:	99 27       	eor	r25, r25
     c52:	81 30       	cpi	r24, 0x01	; 1
     c54:	91 05       	cpc	r25, r1
     c56:	61 f0       	breq	.+24     	; 0xc70 <motor_dir+0x20>
     c58:	82 30       	cpi	r24, 0x02	; 2
     c5a:	91 05       	cpc	r25, r1
     c5c:	1c f4       	brge	.+6      	; 0xc64 <motor_dir+0x14>
     c5e:	89 2b       	or	r24, r25
     c60:	21 f0       	breq	.+8      	; 0xc6a <motor_dir+0x1a>
     c62:	0b c0       	rjmp	.+22     	; 0xc7a <motor_dir+0x2a>
     c64:	02 97       	sbiw	r24, 0x02	; 2
     c66:	39 f0       	breq	.+14     	; 0xc76 <motor_dir+0x26>
     c68:	08 c0       	rjmp	.+16     	; 0xc7a <motor_dir+0x2a>
	{
		case FWD:
		  MOTOR_LINKS_RICHTUNG_PORT &= ~(1<<MOTOR_LINKS_RICHTUNG1);	//0
     c6a:	af 98       	cbi	0x15, 7	; 21
			MOTOR_LINKS_RICHTUNG_PORT |=(1<<MOTOR_LINKS_RICHTUNG0);		//1
     c6c:	ae 9a       	sbi	0x15, 6	; 21
			break;
     c6e:	05 c0       	rjmp	.+10     	; 0xc7a <motor_dir+0x2a>
		case RWD:
			MOTOR_LINKS_RICHTUNG_PORT &= ~(1<<MOTOR_LINKS_RICHTUNG0);	//0	
     c70:	ae 98       	cbi	0x15, 6	; 21
			MOTOR_LINKS_RICHTUNG_PORT |=(1<<MOTOR_LINKS_RICHTUNG1);		//1
     c72:	af 9a       	sbi	0x15, 7	; 21
			break;
     c74:	02 c0       	rjmp	.+4      	; 0xc7a <motor_dir+0x2a>
		case BREAK:
			MOTOR_LINKS_RICHTUNG_PORT &= ~(1<<MOTOR_LINKS_RICHTUNG0);	//0	
     c76:	ae 98       	cbi	0x15, 6	; 21
			MOTOR_LINKS_RICHTUNG_PORT &= ~(1<<MOTOR_LINKS_RICHTUNG1);	//0	
     c78:	af 98       	cbi	0x15, 7	; 21
			break;
		case FREE:
			break;
	}
	
	switch (right_dir)
     c7a:	77 27       	eor	r23, r23
     c7c:	61 30       	cpi	r22, 0x01	; 1
     c7e:	71 05       	cpc	r23, r1
     c80:	69 f0       	breq	.+26     	; 0xc9c <motor_dir+0x4c>
     c82:	62 30       	cpi	r22, 0x02	; 2
     c84:	71 05       	cpc	r23, r1
     c86:	1c f4       	brge	.+6      	; 0xc8e <motor_dir+0x3e>
     c88:	67 2b       	or	r22, r23
     c8a:	29 f0       	breq	.+10     	; 0xc96 <motor_dir+0x46>
     c8c:	08 95       	ret
     c8e:	62 30       	cpi	r22, 0x02	; 2
     c90:	71 05       	cpc	r23, r1
     c92:	39 f0       	breq	.+14     	; 0xca2 <motor_dir+0x52>
     c94:	08 95       	ret
	{
	case FWD:
		MOTOR_RECHTS_RICHTUNG_PORT &= ~(1<<MOTOR_RECHTS_RICHTUNG0);	//0
     c96:	ac 98       	cbi	0x15, 4	; 21
		MOTOR_RECHTS_RICHTUNG_PORT |=(1<<MOTOR_RECHTS_RICHTUNG1);		//1
     c98:	ad 9a       	sbi	0x15, 5	; 21
		break;
     c9a:	08 95       	ret
	case RWD:
		MOTOR_RECHTS_RICHTUNG_PORT &= ~(1<<MOTOR_RECHTS_RICHTUNG1);	//0
     c9c:	ad 98       	cbi	0x15, 5	; 21
		MOTOR_RECHTS_RICHTUNG_PORT |=(1<<MOTOR_RECHTS_RICHTUNG0);		//1
     c9e:	ac 9a       	sbi	0x15, 4	; 21
		break;
     ca0:	08 95       	ret
	case BREAK:
		MOTOR_RECHTS_RICHTUNG_PORT &= ~(1<<MOTOR_RECHTS_RICHTUNG0);	//0
     ca2:	ac 98       	cbi	0x15, 4	; 21
		MOTOR_RECHTS_RICHTUNG_PORT &= ~(1<<MOTOR_RECHTS_RICHTUNG1);	//0
     ca4:	ad 98       	cbi	0x15, 5	; 21
     ca6:	08 95       	ret

00000ca8 <motor_speed>:
     ca8:	2f b7       	in	r18, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	88 23       	and	r24, r24
     cae:	31 f0       	breq	.+12     	; 0xcbc <motor_speed+0x14>
     cb0:	99 27       	eor	r25, r25
     cb2:	81 50       	subi	r24, 0x01	; 1
     cb4:	9f 4f       	sbci	r25, 0xFF	; 255
     cb6:	9b bd       	out	0x2b, r25	; 43
     cb8:	8a bd       	out	0x2a, r24	; 42
     cba:	02 c0       	rjmp	.+4      	; 0xcc0 <motor_speed+0x18>
     cbc:	1b bc       	out	0x2b, r1	; 43
     cbe:	1a bc       	out	0x2a, r1	; 42
     cc0:	66 23       	and	r22, r22
     cc2:	39 f0       	breq	.+14     	; 0xcd2 <motor_speed+0x2a>
     cc4:	86 2f       	mov	r24, r22
     cc6:	99 27       	eor	r25, r25
     cc8:	81 50       	subi	r24, 0x01	; 1
     cca:	9f 4f       	sbci	r25, 0xFF	; 255
     ccc:	99 bd       	out	0x29, r25	; 41
     cce:	88 bd       	out	0x28, r24	; 40
     cd0:	02 c0       	rjmp	.+4      	; 0xcd6 <motor_speed+0x2e>
     cd2:	19 bc       	out	0x29, r1	; 41
     cd4:	18 bc       	out	0x28, r1	; 40
     cd6:	2f bf       	out	0x3f, r18	; 63
     cd8:	08 95       	ret

00000cda <motor_init>:
     cda:	8d 9a       	sbi	0x11, 5	; 17
     cdc:	95 98       	cbi	0x12, 5	; 18
     cde:	84 b3       	in	r24, 0x14	; 20
     ce0:	80 6c       	ori	r24, 0xC0	; 192
     ce2:	84 bb       	out	0x14, r24	; 20
     ce4:	8c 9a       	sbi	0x11, 4	; 17
     ce6:	94 98       	cbi	0x12, 4	; 18
     ce8:	84 b3       	in	r24, 0x14	; 20
     cea:	80 63       	ori	r24, 0x30	; 48
     cec:	84 bb       	out	0x14, r24	; 20
     cee:	60 e0       	ldi	r22, 0x00	; 0
     cf0:	86 2f       	mov	r24, r22
     cf2:	0e 94 28 06 	call	0xc50 <motor_dir>
     cf6:	60 e0       	ldi	r22, 0x00	; 0
     cf8:	86 2f       	mov	r24, r22
     cfa:	0e 94 54 06 	call	0xca8 <motor_speed>
     cfe:	82 e0       	ldi	r24, 0x02	; 2
     d00:	8f bd       	out	0x2f, r24	; 47
     d02:	89 e0       	ldi	r24, 0x09	; 9
     d04:	8e bd       	out	0x2e, r24	; 46
     d06:	8f b5       	in	r24, 0x2f	; 47
     d08:	80 68       	ori	r24, 0x80	; 128
     d0a:	8f bd       	out	0x2f, r24	; 47
     d0c:	8f b5       	in	r24, 0x2f	; 47
     d0e:	80 62       	ori	r24, 0x20	; 32
     d10:	8f bd       	out	0x2f, r24	; 47
     d12:	08 95       	ret

00000d14 <fifo_init>:
* fifo_init (&fifo, buffer, BUF_SIZE);
* \endcode
***************************************************************************/
void fifo_init (fifo_t *f, uint8_t *buffer, const uint8_t size)
{
     d14:	fc 01       	movw	r30, r24
	f->count = 0;		// kein Eintrag im Puffer
     d16:	10 82       	st	Z, r1
	f->pread = f->pwrite = buffer;	// lessezeiger auf Anfang setzen
     d18:	75 83       	std	Z+5, r23	; 0x05
     d1a:	64 83       	std	Z+4, r22	; 0x04
     d1c:	73 83       	std	Z+3, r23	; 0x03
     d1e:	62 83       	std	Z+2, r22	; 0x02
	f->read2end = f->write2end = f->size = size;	// schreibzeiger auf anfang setzen
     d20:	41 83       	std	Z+1, r20	; 0x01
     d22:	47 83       	std	Z+7, r20	; 0x07
     d24:	46 83       	std	Z+6, r20	; 0x06
     d26:	08 95       	ret

00000d28 <fifo_put>:
}

/**************************************************************************/
/*!	\brief Funktion fügt dem Puffer einen weiteren Wert hinzu
*
*			Schreibt das Byte data in die FIFO. Liefert 1 bei Erfolg und 
*			0, falls die FIFO voll ist.
***************************************************************************/
uint8_t fifo_put (fifo_t *f, const uint8_t data)
{
     d28:	fc 01       	movw	r30, r24
	if (f->count >= f->size)
     d2a:	90 81       	ld	r25, Z
     d2c:	81 81       	ldd	r24, Z+1	; 0x01
     d2e:	98 17       	cp	r25, r24
     d30:	18 f0       	brcs	.+6      	; 0xd38 <fifo_put+0x10>
		return 0;
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	08 95       	ret
		
	uint8_t sreg = SREG;
     d38:	9f b7       	in	r25, 0x3f	; 63
	cli();
     d3a:	f8 94       	cli
	
	uint8_t * pwrite = f->pwrite;
     d3c:	a4 81       	ldd	r26, Z+4	; 0x04
     d3e:	b5 81       	ldd	r27, Z+5	; 0x05
	
	*(pwrite++) = data;
     d40:	6d 93       	st	X+, r22
	
	uint8_t write2end = f->write2end;
     d42:	87 81       	ldd	r24, Z+7	; 0x07
	
	if (--write2end == 0)
     d44:	81 50       	subi	r24, 0x01	; 1
     d46:	19 f4       	brne	.+6      	; 0xd4e <fifo_put+0x26>
	{
		write2end = f->size;
     d48:	81 81       	ldd	r24, Z+1	; 0x01
		pwrite -= write2end;
     d4a:	a8 1b       	sub	r26, r24
     d4c:	b1 09       	sbc	r27, r1
	}
	
	f->write2end = write2end;
     d4e:	87 83       	std	Z+7, r24	; 0x07
	f->pwrite = pwrite;
     d50:	b5 83       	std	Z+5, r27	; 0x05
     d52:	a4 83       	std	Z+4, r26	; 0x04


	f->count++;
     d54:	80 81       	ld	r24, Z
     d56:	8f 5f       	subi	r24, 0xFF	; 255
     d58:	80 83       	st	Z, r24
	SREG = sreg;
     d5a:	9f bf       	out	0x3f, r25	; 63
	
	return 1;
     d5c:	81 e0       	ldi	r24, 0x01	; 1
     d5e:	90 e0       	ldi	r25, 0x00	; 0
}
     d60:	08 95       	ret

00000d62 <fifo_get>:


/**************************************************************************/
/*!	\brief Liest den nächsten Wert aus dem Puffer
*
* 		Schreibt in data das nächste Byte aus der FIFO.
*			Liefrt 1 bei Erfolg und 0 falls die FIFO leer ist.
***************************************************************************/
uint8_t fifo_get (fifo_t *f, uint8_t *data)
{
     d62:	cf 93       	push	r28
     d64:	df 93       	push	r29
     d66:	fc 01       	movw	r30, r24
     d68:	eb 01       	movw	r28, r22
	if (!f->count)		return 1;
     d6a:	80 81       	ld	r24, Z
     d6c:	88 23       	and	r24, r24
     d6e:	19 f4       	brne	.+6      	; 0xd76 <fifo_get+0x14>
     d70:	81 e0       	ldi	r24, 0x01	; 1
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	15 c0       	rjmp	.+42     	; 0xda0 <fifo_get+0x3e>
	
	uint8_t sreg = SREG;				// Interruptregister speichern
     d76:	2f b7       	in	r18, 0x3f	; 63
	cli();											// Interrupts verbieten (atomarer code)
     d78:	f8 94       	cli
	
	uint8_t *pread = f->pread;	// lesezeiger speichern
     d7a:	a2 81       	ldd	r26, Z+2	; 0x02
     d7c:	b3 81       	ldd	r27, Z+3	; 0x03
	uint8_t read2end = f->read2end;	// Einträge bis Bufferende
     d7e:	96 81       	ldd	r25, Z+6	; 0x06
	*data = *(pread++);				// daten auslesen
     d80:	8d 91       	ld	r24, X+
     d82:	88 83       	st	Y, r24
	
	if (--read2end == 0)				// Zeiger hat ende erreicht
     d84:	91 50       	subi	r25, 0x01	; 1
     d86:	19 f4       	brne	.+6      	; 0xd8e <fifo_get+0x2c>
	{
		read2end = f->size;				// noch size einträge bis bufferende
     d88:	91 81       	ldd	r25, Z+1	; 0x01
		pread -= read2end;				// lese Zeiger beginnt von vorn
     d8a:	a9 1b       	sub	r26, r25
     d8c:	b1 09       	sbc	r27, r1
	}
	
	f->pread = pread;						// speichern des neuen Lesezeigers
     d8e:	b3 83       	std	Z+3, r27	; 0x03
     d90:	a2 83       	std	Z+2, r26	; 0x02
	f->read2end = read2end;			// anzahl der einträge bis bufferende
     d92:	96 83       	std	Z+6, r25	; 0x06

	f->count--;									// ein Eintrag weniger im Buffer
     d94:	80 81       	ld	r24, Z
     d96:	81 50       	subi	r24, 0x01	; 1
     d98:	80 83       	st	Z, r24
	SREG = sreg;								// Interrupts wiederherstellen
     d9a:	2f bf       	out	0x3f, r18	; 63

	return 0;
     d9c:	80 e0       	ldi	r24, 0x00	; 0
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	df 91       	pop	r29
     da2:	cf 91       	pop	r28
     da4:	08 95       	ret

00000da6 <command_put>:
const char Str_CR[] PROGMEM = "\r\n"; 
const char Str_BOT[] PROGMEM = "BOT:\\>";

void command_put(uint8_t last_c)
{
     da6:	cf 93       	push	r28
     da8:	df 93       	push	r29
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
     dae:	21 97       	sbiw	r28, 0x01	; 1
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	f8 94       	cli
     db4:	de bf       	out	0x3e, r29	; 62
     db6:	0f be       	out	0x3f, r0	; 63
     db8:	cd bf       	out	0x3d, r28	; 61
     dba:	89 83       	std	Y+1, r24	; 0x01
	if(last_c != (uint8_t)(-1)){				// Zeichen empfangen
     dbc:	89 81       	ldd	r24, Y+1	; 0x01
     dbe:	8f 3f       	cpi	r24, 0xFF	; 255
     dc0:	09 f4       	brne	.+2      	; 0xdc4 <command_put+0x1e>
     dc2:	de c0       	rjmp	.+444    	; 0xf80 <command_put+0x1da>
		if(last_c == 13){								// ENTER wurde gedrückt
     dc4:	89 81       	ldd	r24, Y+1	; 0x01
     dc6:	8d 30       	cpi	r24, 0x0D	; 13
     dc8:	09 f0       	breq	.+2      	; 0xdcc <command_put+0x26>
     dca:	8a c0       	rjmp	.+276    	; 0xee0 <command_put+0x13a>
			*ptext++ = '\0';								// String mit NULL terminieren
     dcc:	a2 e6       	ldi	r26, 0x62	; 98
     dce:	b0 e0       	ldi	r27, 0x00	; 0
     dd0:	8d 91       	ld	r24, X+
     dd2:	9c 91       	ld	r25, X
     dd4:	11 97       	sbiw	r26, 0x01	; 1
     dd6:	fc 01       	movw	r30, r24
     dd8:	10 82       	st	Z, r1
     dda:	01 96       	adiw	r24, 0x01	; 1
     ddc:	8d 93       	st	X+, r24
     dde:	9c 93       	st	X, r25
			ptext = text;										// Pointer wieder auf Anfang setzen
     de0:	81 ec       	ldi	r24, 0xC1	; 193
     de2:	90 e0       	ldi	r25, 0x00	; 0
     de4:	90 93 63 00 	sts	0x0063, r25
     de8:	80 93 62 00 	sts	0x0062, r24
			nText=0;												// 
     dec:	10 92 c0 00 	sts	0x00C0, r1
			if((strcmp(text, "?")==0) || 
     df0:	64 e6       	ldi	r22, 0x64	; 100
     df2:	70 e0       	ldi	r23, 0x00	; 0
     df4:	81 ec       	ldi	r24, 0xC1	; 193
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	0e 94 60 09 	call	0x12c0 <strcmp>
     dfc:	00 97       	sbiw	r24, 0x00	; 0
     dfe:	41 f0       	breq	.+16     	; 0xe10 <command_put+0x6a>
     e00:	66 e6       	ldi	r22, 0x66	; 102
     e02:	70 e0       	ldi	r23, 0x00	; 0
     e04:	81 ec       	ldi	r24, 0xC1	; 193
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	0e 94 60 09 	call	0x12c0 <strcmp>
     e0c:	00 97       	sbiw	r24, 0x00	; 0
     e0e:	21 f4       	brne	.+8      	; 0xe18 <command_put+0x72>
				(strcmp(text, "help")==0)){								// ? oder help
				command = CMD_HELP;
     e10:	84 e0       	ldi	r24, 0x04	; 4
     e12:	80 93 a4 00 	sts	0x00A4, r24
				return;
     e16:	b6 c0       	rjmp	.+364    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "status")==0){				// status
     e18:	6b e6       	ldi	r22, 0x6B	; 107
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	81 ec       	ldi	r24, 0xC1	; 193
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	0e 94 60 09 	call	0x12c0 <strcmp>
     e24:	00 97       	sbiw	r24, 0x00	; 0
     e26:	21 f4       	brne	.+8      	; 0xe30 <command_put+0x8a>
				command = CMD_STATUS;
     e28:	83 e0       	ldi	r24, 0x03	; 3
     e2a:	80 93 a4 00 	sts	0x00A4, r24
				return;
     e2e:	aa c0       	rjmp	.+340    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "cls")==0){					// cls
     e30:	62 e7       	ldi	r22, 0x72	; 114
     e32:	70 e0       	ldi	r23, 0x00	; 0
     e34:	81 ec       	ldi	r24, 0xC1	; 193
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	0e 94 60 09 	call	0x12c0 <strcmp>
     e3c:	00 97       	sbiw	r24, 0x00	; 0
     e3e:	21 f4       	brne	.+8      	; 0xe48 <command_put+0xa2>
				command = CMD_CLS;
     e40:	82 e0       	ldi	r24, 0x02	; 2
     e42:	80 93 a4 00 	sts	0x00A4, r24
				return;
     e46:	9e c0       	rjmp	.+316    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "move")==0){					// move
     e48:	66 e7       	ldi	r22, 0x76	; 118
     e4a:	70 e0       	ldi	r23, 0x00	; 0
     e4c:	81 ec       	ldi	r24, 0xC1	; 193
     e4e:	90 e0       	ldi	r25, 0x00	; 0
     e50:	0e 94 60 09 	call	0x12c0 <strcmp>
     e54:	00 97       	sbiw	r24, 0x00	; 0
     e56:	21 f4       	brne	.+8      	; 0xe60 <command_put+0xba>
				command = CMD_MOVE;
     e58:	85 e0       	ldi	r24, 0x05	; 5
     e5a:	80 93 a4 00 	sts	0x00A4, r24
				return;
     e5e:	92 c0       	rjmp	.+292    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "demo")==0){					// demo
     e60:	6b e7       	ldi	r22, 0x7B	; 123
     e62:	70 e0       	ldi	r23, 0x00	; 0
     e64:	81 ec       	ldi	r24, 0xC1	; 193
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	0e 94 60 09 	call	0x12c0 <strcmp>
     e6c:	00 97       	sbiw	r24, 0x00	; 0
     e6e:	21 f4       	brne	.+8      	; 0xe78 <command_put+0xd2>
				command = CMD_DEMO;
     e70:	86 e0       	ldi	r24, 0x06	; 6
     e72:	80 93 a4 00 	sts	0x00A4, r24
				return;
     e76:	86 c0       	rjmp	.+268    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "debug")==0){				// debug
     e78:	60 e8       	ldi	r22, 0x80	; 128
     e7a:	70 e0       	ldi	r23, 0x00	; 0
     e7c:	81 ec       	ldi	r24, 0xC1	; 193
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	0e 94 60 09 	call	0x12c0 <strcmp>
     e84:	00 97       	sbiw	r24, 0x00	; 0
     e86:	21 f4       	brne	.+8      	; 0xe90 <command_put+0xea>
				command = CMD_DEBUG;
     e88:	8a e0       	ldi	r24, 0x0A	; 10
     e8a:	80 93 a4 00 	sts	0x00A4, r24
				return;
     e8e:	7a c0       	rjmp	.+244    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "debug cmd")==0){	// debug encoder
     e90:	66 e8       	ldi	r22, 0x86	; 134
     e92:	70 e0       	ldi	r23, 0x00	; 0
     e94:	81 ec       	ldi	r24, 0xC1	; 193
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	0e 94 60 09 	call	0x12c0 <strcmp>
     e9c:	00 97       	sbiw	r24, 0x00	; 0
     e9e:	21 f4       	brne	.+8      	; 0xea8 <command_put+0x102>
				command = CMD_DB_CMD;
     ea0:	8b e0       	ldi	r24, 0x0B	; 11
     ea2:	80 93 a4 00 	sts	0x00A4, r24
				return;
     ea6:	6e c0       	rjmp	.+220    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "debug enc")==0){	// debug commandline
     ea8:	60 e9       	ldi	r22, 0x90	; 144
     eaa:	70 e0       	ldi	r23, 0x00	; 0
     eac:	81 ec       	ldi	r24, 0xC1	; 193
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	0e 94 60 09 	call	0x12c0 <strcmp>
     eb4:	00 97       	sbiw	r24, 0x00	; 0
     eb6:	21 f4       	brne	.+8      	; 0xec0 <command_put+0x11a>
				command = CMD_DB_ENC;
     eb8:	8c e0       	ldi	r24, 0x0C	; 12
     eba:	80 93 a4 00 	sts	0x00A4, r24
				return;			
     ebe:	62 c0       	rjmp	.+196    	; 0xf84 <command_put+0x1de>
			} else if(strcmp(text, "debug reg")==0){		// debug regler
     ec0:	6a e9       	ldi	r22, 0x9A	; 154
     ec2:	70 e0       	ldi	r23, 0x00	; 0
     ec4:	81 ec       	ldi	r24, 0xC1	; 193
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	0e 94 60 09 	call	0x12c0 <strcmp>
     ecc:	00 97       	sbiw	r24, 0x00	; 0
     ece:	21 f4       	brne	.+8      	; 0xed8 <command_put+0x132>
				command = CMD_DB_REG;
     ed0:	8d e0       	ldi	r24, 0x0D	; 13
     ed2:	80 93 a4 00 	sts	0x00A4, r24
				return;
     ed6:	56 c0       	rjmp	.+172    	; 0xf84 <command_put+0x1de>
			} else {																			// No Command
				command = CMD_NOC;
     ed8:	81 e0       	ldi	r24, 0x01	; 1
     eda:	80 93 a4 00 	sts	0x00A4, r24
				return;
     ede:	52 c0       	rjmp	.+164    	; 0xf84 <command_put+0x1de>
			}
		}	else if(last_c ==27){
     ee0:	89 81       	ldd	r24, Y+1	; 0x01
     ee2:	8b 31       	cpi	r24, 0x1B	; 27
     ee4:	49 f5       	brne	.+82     	; 0xf38 <command_put+0x192>
			last_c = uart_getc();
     ee6:	0e 94 4e 05 	call	0xa9c <uart_getc>
     eea:	89 83       	std	Y+1, r24	; 0x01
			if(last_c=='['){
     eec:	89 81       	ldd	r24, Y+1	; 0x01
     eee:	8b 35       	cpi	r24, 0x5B	; 91
     ef0:	f9 f4       	brne	.+62     	; 0xf30 <command_put+0x18a>
				last_c = uart_getc();
     ef2:	0e 94 4e 05 	call	0xa9c <uart_getc>
     ef6:	89 83       	std	Y+1, r24	; 0x01
				if(last_c == 'A'){												// Pfeil hoch
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	81 34       	cpi	r24, 0x41	; 65
     efc:	21 f4       	brne	.+8      	; 0xf06 <command_put+0x160>
					command = CMD_UP;
     efe:	81 e4       	ldi	r24, 0x41	; 65
     f00:	80 93 a4 00 	sts	0x00A4, r24
					return;
     f04:	3f c0       	rjmp	.+126    	; 0xf84 <command_put+0x1de>
				}	 else if(last_c == 'B'){								// Pfeil runter
     f06:	89 81       	ldd	r24, Y+1	; 0x01
     f08:	82 34       	cpi	r24, 0x42	; 66
     f0a:	21 f4       	brne	.+8      	; 0xf14 <command_put+0x16e>
					command = CMD_DOWN;
     f0c:	82 e4       	ldi	r24, 0x42	; 66
     f0e:	80 93 a4 00 	sts	0x00A4, r24
					return;
     f12:	38 c0       	rjmp	.+112    	; 0xf84 <command_put+0x1de>
				} else if(last_c == 'C'){								// Pfeil rechts
     f14:	89 81       	ldd	r24, Y+1	; 0x01
     f16:	83 34       	cpi	r24, 0x43	; 67
     f18:	21 f4       	brne	.+8      	; 0xf22 <command_put+0x17c>
					command = CMD_RIGHT;
     f1a:	85 e4       	ldi	r24, 0x45	; 69
     f1c:	80 93 a4 00 	sts	0x00A4, r24
					return;
     f20:	31 c0       	rjmp	.+98     	; 0xf84 <command_put+0x1de>
				} else if(last_c == 'D'){								// Pfeil links
     f22:	89 81       	ldd	r24, Y+1	; 0x01
     f24:	84 34       	cpi	r24, 0x44	; 68
     f26:	61 f5       	brne	.+88     	; 0xf80 <command_put+0x1da>
					command = CMD_LEFT;
     f28:	84 e4       	ldi	r24, 0x44	; 68
     f2a:	80 93 a4 00 	sts	0x00A4, r24
					return;
     f2e:	2a c0       	rjmp	.+84     	; 0xf84 <command_put+0x1de>
				}
			} else {																		// Escape
				command = CMD_ESCAPE;
     f30:	8b e1       	ldi	r24, 0x1B	; 27
     f32:	80 93 a4 00 	sts	0x00A4, r24
				return;
     f36:	26 c0       	rjmp	.+76     	; 0xf84 <command_put+0x1de>
			}
		} else {
				if((last_c == 10) ||(last_c == 8) || (nText == (MAX_BUF-4)) ){	// Zeichen ignorieren
     f38:	89 81       	ldd	r24, Y+1	; 0x01
     f3a:	8a 30       	cpi	r24, 0x0A	; 10
     f3c:	41 f0       	breq	.+16     	; 0xf4e <command_put+0x1a8>
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	88 30       	cpi	r24, 0x08	; 8
     f42:	29 f0       	breq	.+10     	; 0xf4e <command_put+0x1a8>
     f44:	80 91 c0 00 	lds	r24, 0x00C0
     f48:	80 36       	cpi	r24, 0x60	; 96
     f4a:	09 f0       	breq	.+2      	; 0xf4e <command_put+0x1a8>
     f4c:	03 c0       	rjmp	.+6      	; 0xf54 <command_put+0x1ae>
					command = CMD_NOP;
     f4e:	10 92 a4 00 	sts	0x00A4, r1
					return;
     f52:	18 c0       	rjmp	.+48     	; 0xf84 <command_put+0x1de>
				}
				*ptext++ = last_c;						// Zeichen Speichern
     f54:	a2 e6       	ldi	r26, 0x62	; 98
     f56:	b0 e0       	ldi	r27, 0x00	; 0
     f58:	8d 91       	ld	r24, X+
     f5a:	9c 91       	ld	r25, X
     f5c:	11 97       	sbiw	r26, 0x01	; 1
     f5e:	fc 01       	movw	r30, r24
     f60:	29 81       	ldd	r18, Y+1	; 0x01
     f62:	20 83       	st	Z, r18
     f64:	01 96       	adiw	r24, 0x01	; 1
     f66:	8d 93       	st	X+, r24
     f68:	9c 93       	st	X, r25
				uart_putc(last_c);						// ausgeben
     f6a:	89 81       	ldd	r24, Y+1	; 0x01
     f6c:	0e 94 6e 03 	call	0x6dc <uart_putc>
				nText++;			
     f70:	80 91 c0 00 	lds	r24, 0x00C0
     f74:	8f 5f       	subi	r24, 0xFF	; 255
     f76:	80 93 c0 00 	sts	0x00C0, r24
				command = CMD_NOP;
     f7a:	10 92 a4 00 	sts	0x00A4, r1
				return;
     f7e:	02 c0       	rjmp	.+4      	; 0xf84 <command_put+0x1de>
		}
	} 
	command = CMD_NOP;
     f80:	10 92 a4 00 	sts	0x00A4, r1
     f84:	21 96       	adiw	r28, 0x01	; 1
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	f8 94       	cli
     f8a:	de bf       	out	0x3e, r29	; 62
     f8c:	0f be       	out	0x3f, r0	; 63
     f8e:	cd bf       	out	0x3d, r28	; 61
     f90:	df 91       	pop	r29
     f92:	cf 91       	pop	r28
     f94:	08 95       	ret

00000f96 <command_get>:
	return;
}


uint8_t command_get(void)
{
     f96:	cf 93       	push	r28
     f98:	df 93       	push	r29
     f9a:	cd b7       	in	r28, 0x3d	; 61
     f9c:	de b7       	in	r29, 0x3e	; 62
	return command;
     f9e:	80 91 a4 00 	lds	r24, 0x00A4
     fa2:	99 27       	eor	r25, r25
     fa4:	df 91       	pop	r29
     fa6:	cf 91       	pop	r28
     fa8:	08 95       	ret

00000faa <command_text>:
}

uint8_t *command_text(void)
{
     faa:	cf 93       	push	r28
     fac:	df 93       	push	r29
     fae:	cd b7       	in	r28, 0x3d	; 61
     fb0:	de b7       	in	r29, 0x3e	; 62
	return text;
     fb2:	81 ec       	ldi	r24, 0xC1	; 193
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	df 91       	pop	r29
     fb8:	cf 91       	pop	r28
     fba:	08 95       	ret

00000fbc <command_prompt>:
}

void command_prompt(uint8_t command)
{
     fbc:	cf 93       	push	r28
     fbe:	df 93       	push	r29
     fc0:	cd b7       	in	r28, 0x3d	; 61
     fc2:	de b7       	in	r29, 0x3e	; 62
     fc4:	23 97       	sbiw	r28, 0x03	; 3
     fc6:	0f b6       	in	r0, 0x3f	; 63
     fc8:	f8 94       	cli
     fca:	de bf       	out	0x3e, r29	; 62
     fcc:	0f be       	out	0x3f, r0	; 63
     fce:	cd bf       	out	0x3d, r28	; 61
     fd0:	89 83       	std	Y+1, r24	; 0x01
		switch (command) {
     fd2:	89 81       	ldd	r24, Y+1	; 0x01
     fd4:	28 2f       	mov	r18, r24
     fd6:	33 27       	eor	r19, r19
     fd8:	3b 83       	std	Y+3, r19	; 0x03
     fda:	2a 83       	std	Y+2, r18	; 0x02
     fdc:	8a 81       	ldd	r24, Y+2	; 0x02
     fde:	9b 81       	ldd	r25, Y+3	; 0x03
     fe0:	8a 30       	cpi	r24, 0x0A	; 10
     fe2:	91 05       	cpc	r25, r1
     fe4:	09 f4       	brne	.+2      	; 0xfe8 <command_prompt+0x2c>
     fe6:	f8 c0       	rjmp	.+496    	; 0x11d8 <command_prompt+0x21c>
     fe8:	2a 81       	ldd	r18, Y+2	; 0x02
     fea:	3b 81       	ldd	r19, Y+3	; 0x03
     fec:	2b 30       	cpi	r18, 0x0B	; 11
     fee:	31 05       	cpc	r19, r1
     ff0:	84 f5       	brge	.+96     	; 0x1052 <command_prompt+0x96>
     ff2:	8a 81       	ldd	r24, Y+2	; 0x02
     ff4:	9b 81       	ldd	r25, Y+3	; 0x03
     ff6:	83 30       	cpi	r24, 0x03	; 3
     ff8:	91 05       	cpc	r25, r1
     ffa:	09 f4       	brne	.+2      	; 0xffe <command_prompt+0x42>
     ffc:	b8 c0       	rjmp	.+368    	; 0x116e <command_prompt+0x1b2>
     ffe:	2a 81       	ldd	r18, Y+2	; 0x02
    1000:	3b 81       	ldd	r19, Y+3	; 0x03
    1002:	24 30       	cpi	r18, 0x04	; 4
    1004:	31 05       	cpc	r19, r1
    1006:	94 f4       	brge	.+36     	; 0x102c <command_prompt+0x70>
    1008:	8a 81       	ldd	r24, Y+2	; 0x02
    100a:	9b 81       	ldd	r25, Y+3	; 0x03
    100c:	81 30       	cpi	r24, 0x01	; 1
    100e:	91 05       	cpc	r25, r1
    1010:	09 f4       	brne	.+2      	; 0x1014 <command_prompt+0x58>
    1012:	40 c0       	rjmp	.+128    	; 0x1094 <command_prompt+0xd8>
    1014:	2a 81       	ldd	r18, Y+2	; 0x02
    1016:	3b 81       	ldd	r19, Y+3	; 0x03
    1018:	22 30       	cpi	r18, 0x02	; 2
    101a:	31 05       	cpc	r19, r1
    101c:	0c f0       	brlt	.+2      	; 0x1020 <command_prompt+0x64>
    101e:	fd c0       	rjmp	.+506    	; 0x121a <command_prompt+0x25e>
    1020:	8a 81       	ldd	r24, Y+2	; 0x02
    1022:	9b 81       	ldd	r25, Y+3	; 0x03
    1024:	00 97       	sbiw	r24, 0x00	; 0
    1026:	09 f4       	brne	.+2      	; 0x102a <command_prompt+0x6e>
    1028:	0e c1       	rjmp	.+540    	; 0x1246 <command_prompt+0x28a>
    102a:	09 c1       	rjmp	.+530    	; 0x123e <command_prompt+0x282>
    102c:	2a 81       	ldd	r18, Y+2	; 0x02
    102e:	3b 81       	ldd	r19, Y+3	; 0x03
    1030:	25 30       	cpi	r18, 0x05	; 5
    1032:	31 05       	cpc	r19, r1
    1034:	09 f4       	brne	.+2      	; 0x1038 <command_prompt+0x7c>
    1036:	b6 c0       	rjmp	.+364    	; 0x11a4 <command_prompt+0x1e8>
    1038:	8a 81       	ldd	r24, Y+2	; 0x02
    103a:	9b 81       	ldd	r25, Y+3	; 0x03
    103c:	85 30       	cpi	r24, 0x05	; 5
    103e:	91 05       	cpc	r25, r1
    1040:	0c f4       	brge	.+2      	; 0x1044 <command_prompt+0x88>
    1042:	48 c0       	rjmp	.+144    	; 0x10d4 <command_prompt+0x118>
    1044:	2a 81       	ldd	r18, Y+2	; 0x02
    1046:	3b 81       	ldd	r19, Y+3	; 0x03
    1048:	26 30       	cpi	r18, 0x06	; 6
    104a:	31 05       	cpc	r19, r1
    104c:	09 f4       	brne	.+2      	; 0x1050 <command_prompt+0x94>
    104e:	b7 c0       	rjmp	.+366    	; 0x11be <command_prompt+0x202>
    1050:	f6 c0       	rjmp	.+492    	; 0x123e <command_prompt+0x282>
    1052:	8a 81       	ldd	r24, Y+2	; 0x02
    1054:	9b 81       	ldd	r25, Y+3	; 0x03
    1056:	83 34       	cpi	r24, 0x43	; 67
    1058:	91 05       	cpc	r25, r1
    105a:	9c f4       	brge	.+38     	; 0x1082 <command_prompt+0xc6>
    105c:	2a 81       	ldd	r18, Y+2	; 0x02
    105e:	3b 81       	ldd	r19, Y+3	; 0x03
    1060:	21 34       	cpi	r18, 0x41	; 65
    1062:	31 05       	cpc	r19, r1
    1064:	0c f0       	brlt	.+2      	; 0x1068 <command_prompt+0xac>
    1066:	ef c0       	rjmp	.+478    	; 0x1246 <command_prompt+0x28a>
    1068:	8a 81       	ldd	r24, Y+2	; 0x02
    106a:	9b 81       	ldd	r25, Y+3	; 0x03
    106c:	8e 30       	cpi	r24, 0x0E	; 14
    106e:	91 05       	cpc	r25, r1
    1070:	0c f4       	brge	.+2      	; 0x1074 <command_prompt+0xb8>
    1072:	e9 c0       	rjmp	.+466    	; 0x1246 <command_prompt+0x28a>
    1074:	2a 81       	ldd	r18, Y+2	; 0x02
    1076:	3b 81       	ldd	r19, Y+3	; 0x03
    1078:	2b 31       	cpi	r18, 0x1B	; 27
    107a:	31 05       	cpc	r19, r1
    107c:	09 f4       	brne	.+2      	; 0x1080 <command_prompt+0xc4>
    107e:	d6 c0       	rjmp	.+428    	; 0x122c <command_prompt+0x270>
    1080:	de c0       	rjmp	.+444    	; 0x123e <command_prompt+0x282>
    1082:	8a 81       	ldd	r24, Y+2	; 0x02
    1084:	9b 81       	ldd	r25, Y+3	; 0x03
    1086:	84 54       	subi	r24, 0x44	; 68
    1088:	90 40       	sbci	r25, 0x00	; 0
    108a:	82 30       	cpi	r24, 0x02	; 2
    108c:	91 05       	cpc	r25, r1
    108e:	08 f0       	brcs	.+2      	; 0x1092 <command_prompt+0xd6>
    1090:	d6 c0       	rjmp	.+428    	; 0x123e <command_prompt+0x282>
    1092:	d9 c0       	rjmp	.+434    	; 0x1246 <command_prompt+0x28a>
			case CMD_NOP: break;
			case CMD_NOC: 
				uart_puts_p(PSTR("\r\n Diesen Befehl kenne ich nicht.\r\n"));
    1094:	8e e5       	ldi	r24, 0x5E	; 94
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Du hast \""));
    109c:	82 e8       	ldi	r24, 0x82	; 130
    109e:	90 e0       	ldi	r25, 0x00	; 0
    10a0:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts(command_text());
    10a4:	0e 94 d5 07 	call	0xfaa <command_text>
    10a8:	0e 94 8d 03 	call	0x71a <uart_puts>
				uart_puts_p(PSTR("\" eingegeben. "));
    10ac:	8d e8       	ldi	r24, 0x8D	; 141
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puti((uint8_t)*command_text());
    10b4:	0e 94 d5 07 	call	0xfaa <command_text>
    10b8:	fc 01       	movw	r30, r24
    10ba:	80 81       	ld	r24, Z
    10bc:	99 27       	eor	r25, r25
    10be:	0e 94 fe 03 	call	0x7fc <uart_puti>
				uart_puts_p(Str_CR);
    10c2:	84 e5       	ldi	r24, 0x54	; 84
    10c4:	90 e0       	ldi	r25, 0x00	; 0
    10c6:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_BOT);	
    10ca:	87 e5       	ldi	r24, 0x57	; 87
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				break;
    10d2:	b9 c0       	rjmp	.+370    	; 0x1246 <command_prompt+0x28a>
			case CMD_HELP: 
				uart_puts_p(PSTR("\f *** Hallo! ***"));
    10d4:	8c e9       	ldi	r24, 0x9C	; 156
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    10dc:	84 e5       	ldi	r24, 0x54	; 84
    10de:	90 e0       	ldi	r25, 0x00	; 0
    10e0:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Ich bin ein kleiner Roboter. Was moechtest du mit mir machen?"));
    10e4:	8d ea       	ldi	r24, 0xAD	; 173
    10e6:	90 e0       	ldi	r25, 0x00	; 0
    10e8:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    10ec:	84 e5       	ldi	r24, 0x54	; 84
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Mit dem Befehl:"));
    10f4:	8c ee       	ldi	r24, 0xEC	; 236
    10f6:	90 e0       	ldi	r25, 0x00	; 0
    10f8:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    10fc:	84 e5       	ldi	r24, 0x54	; 84
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - ?       Zeige ich die alle Befehle die ich verstehe."));
    1104:	8d ef       	ldi	r24, 0xFD	; 253
    1106:	90 e0       	ldi	r25, 0x00	; 0
    1108:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    110c:	84 e5       	ldi	r24, 0x54	; 84
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - status  kannst du sehen, wie ich mich fuehle."));
    1114:	85 e3       	ldi	r24, 0x35	; 53
    1116:	91 e0       	ldi	r25, 0x01	; 1
    1118:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    111c:	84 e5       	ldi	r24, 0x54	; 84
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - cls     loescht du den Bildschirm."));
    1124:	86 e6       	ldi	r24, 0x66	; 102
    1126:	91 e0       	ldi	r25, 0x01	; 1
    1128:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    112c:	84 e5       	ldi	r24, 0x54	; 84
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - move    kannst du mich fahren lassen."));
    1134:	8c e8       	ldi	r24, 0x8C	; 140
    1136:	91 e0       	ldi	r25, 0x01	; 1
    1138:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    113c:	84 e5       	ldi	r24, 0x54	; 84
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - demo    fahre ich ein wenig hin und her."));
    1144:	85 eb       	ldi	r24, 0xB5	; 181
    1146:	91 e0       	ldi	r25, 0x01	; 1
    1148:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    114c:	84 e5       	ldi	r24, 0x54	; 84
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - debug   Zeige ich dir Aktuelle Statusmeldungen."));
    1154:	81 ee       	ldi	r24, 0xE1	; 225
    1156:	91 e0       	ldi	r25, 0x01	; 1
    1158:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_CR);
    115c:	84 e5       	ldi	r24, 0x54	; 84
    115e:	90 e0       	ldi	r25, 0x00	; 0
    1160:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_BOT);	
    1164:	87 e5       	ldi	r24, 0x57	; 87
    1166:	90 e0       	ldi	r25, 0x00	; 0
    1168:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				break;
    116c:	6c c0       	rjmp	.+216    	; 0x1246 <command_prompt+0x28a>
			case CMD_STATUS:
				uart_puts_p(PSTR("\f *** Hi! ***\r\n"));
    116e:	84 e1       	ldi	r24, 0x14	; 20
    1170:	92 e0       	ldi	r25, 0x02	; 2
    1172:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Ich bin heute schon seit "));
    1176:	84 e2       	ldi	r24, 0x24	; 36
    1178:	92 e0       	ldi	r25, 0x02	; 2
    117a:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_printtime();
    117e:	0e 94 20 04 	call	0x840 <uart_printtime>
				uart_puts_p(PSTR(" unterwegs.\r\n"));
    1182:	8f e3       	ldi	r24, 0x3F	; 63
    1184:	92 e0       	ldi	r25, 0x02	; 2
    1186:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Ich fuehle mich gut und meine Akkuspannung betraegt noch:"));
    118a:	8d e4       	ldi	r24, 0x4D	; 77
    118c:	92 e0       	ldi	r25, 0x02	; 2
    118e:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" 12V\r\n"));
    1192:	88 e8       	ldi	r24, 0x88	; 136
    1194:	92 e0       	ldi	r25, 0x02	; 2
    1196:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_BOT);	
    119a:	87 e5       	ldi	r24, 0x57	; 87
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				break;
    11a2:	51 c0       	rjmp	.+162    	; 0x1246 <command_prompt+0x28a>
			case CMD_MOVE: 
				uart_puts_p(PSTR("\f *** Gib Gas! ***\r\n"));
    11a4:	8f e8       	ldi	r24, 0x8F	; 143
    11a6:	92 e0       	ldi	r25, 0x02	; 2
    11a8:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Mit den Pfeiltasten kannst du mich nun steuern.\r\n"));
    11ac:	84 ea       	ldi	r24, 0xA4	; 164
    11ae:	92 e0       	ldi	r25, 0x02	; 2
    11b0:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Mit Esc beendest du die Fahrt."));	
    11b4:	87 ed       	ldi	r24, 0xD7	; 215
    11b6:	92 e0       	ldi	r25, 0x02	; 2
    11b8:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				break;
    11bc:	44 c0       	rjmp	.+136    	; 0x1246 <command_prompt+0x28a>
			case CMD_DEMO: 
				uart_puts_p(PSTR("\f *** DEMO *** \r\n"));
    11be:	87 ef       	ldi	r24, 0xF7	; 247
    11c0:	92 e0       	ldi	r25, 0x02	; 2
    11c2:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Ich fahre ein wenig hin und her.\r\n"));
    11c6:	89 e0       	ldi	r24, 0x09	; 9
    11c8:	93 e0       	ldi	r25, 0x03	; 3
    11ca:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Mit Esc beendest du die Fahrt."));	
    11ce:	8d e2       	ldi	r24, 0x2D	; 45
    11d0:	93 e0       	ldi	r25, 0x03	; 3
    11d2:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				break;					
    11d6:	37 c0       	rjmp	.+110    	; 0x1246 <command_prompt+0x28a>
			case CMD_DEBUG: 
				uart_puts_p(PSTR("\f *** DEBUG *** \r\n"));
    11d8:	8d e4       	ldi	r24, 0x4D	; 77
    11da:	93 e0       	ldi	r25, 0x03	; 3
    11dc:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Ich kann dir verschiedene DEBUGinfomationen ausgeben:\r\n"));
    11e0:	80 e6       	ldi	r24, 0x60	; 96
    11e2:	93 e0       	ldi	r25, 0x03	; 3
    11e4:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" Mit dem Befehl:\r\n"));
    11e8:	89 e9       	ldi	r24, 0x99	; 153
    11ea:	93 e0       	ldi	r25, 0x03	; 3
    11ec:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - debug cmd      gebe ich dir alle gesendete Zeichen aus.\r\n"));
    11f0:	8c ea       	ldi	r24, 0xAC	; 172
    11f2:	93 e0       	ldi	r25, 0x03	; 3
    11f4:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - debug enc      gebe ich die die aktuellen Encoderwerte aus.\r\n"));
    11f8:	89 ee       	ldi	r24, 0xE9	; 233
    11fa:	93 e0       	ldi	r25, 0x03	; 3
    11fc:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - debug reg      gebe ich dir aktuelle Reglerwerte aus.\r\n"));
    1200:	8a e2       	ldi	r24, 0x2A	; 42
    1202:	94 e0       	ldi	r25, 0x04	; 4
    1204:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(PSTR(" - Die Anzeige beendest du mit escape.\r\n"));
    1208:	85 e6       	ldi	r24, 0x65	; 101
    120a:	94 e0       	ldi	r25, 0x04	; 4
    120c:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_BOT);	break;
    1210:	87 e5       	ldi	r24, 0x57	; 87
    1212:	90 e0       	ldi	r25, 0x00	; 0
    1214:	0e 94 b0 03 	call	0x760 <uart_puts_p>
    1218:	16 c0       	rjmp	.+44     	; 0x1246 <command_prompt+0x28a>
			case CMD_CLS: 
				uart_puts_p(PSTR("\f"));
    121a:	8e e8       	ldi	r24, 0x8E	; 142
    121c:	94 e0       	ldi	r25, 0x04	; 4
    121e:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_BOT);		
    1222:	87 e5       	ldi	r24, 0x57	; 87
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				break;
    122a:	0d c0       	rjmp	.+26     	; 0x1246 <command_prompt+0x28a>
			case CMD_ESCAPE:
				uart_puts_p(Str_CR);	
    122c:	84 e5       	ldi	r24, 0x54	; 84
    122e:	90 e0       	ldi	r25, 0x00	; 0
    1230:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				uart_puts_p(Str_BOT);	 
    1234:	87 e5       	ldi	r24, 0x57	; 87
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	0e 94 b0 03 	call	0x760 <uart_puts_p>
				break;
    123c:	04 c0       	rjmp	.+8      	; 0x1246 <command_prompt+0x28a>
			case CMD_UP: 	 
				break;
			case CMD_DOWN: 
				break;
			case CMD_LEFT: break;
			case CMD_RIGHT: break;
			case CMD_DB_CMD: break;
			case CMD_DB_ENC: break;
			case CMD_DB_REG: break;
			default: uart_puts_p(PSTR("\f Fehler in der Commandline!!\r\n"));
    123e:	80 e9       	ldi	r24, 0x90	; 144
    1240:	94 e0       	ldi	r25, 0x04	; 4
    1242:	0e 94 b0 03 	call	0x760 <uart_puts_p>
    1246:	23 96       	adiw	r28, 0x03	; 3
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	f8 94       	cli
    124c:	de bf       	out	0x3e, r29	; 62
    124e:	0f be       	out	0x3f, r0	; 63
    1250:	cd bf       	out	0x3d, r28	; 61
    1252:	df 91       	pop	r29
    1254:	cf 91       	pop	r28
    1256:	08 95       	ret

00001258 <pcc_init>:
*	\brief Initialisiert die PC Kommunikation
*
***************************************************************************/
void pcc_init(pcc_t *daten)
{
    1258:	cf 93       	push	r28
    125a:	df 93       	push	r29
    125c:	cd b7       	in	r28, 0x3d	; 61
    125e:	de b7       	in	r29, 0x3e	; 62
    1260:	22 97       	sbiw	r28, 0x02	; 2
    1262:	0f b6       	in	r0, 0x3f	; 63
    1264:	f8 94       	cli
    1266:	de bf       	out	0x3e, r29	; 62
    1268:	0f be       	out	0x3f, r0	; 63
    126a:	cd bf       	out	0x3d, r28	; 61
    126c:	9a 83       	std	Y+2, r25	; 0x02
    126e:	89 83       	std	Y+1, r24	; 0x01
	ppcc=daten;
    1270:	89 81       	ldd	r24, Y+1	; 0x01
    1272:	9a 81       	ldd	r25, Y+2	; 0x02
    1274:	90 93 26 01 	sts	0x0126, r25
    1278:	80 93 25 01 	sts	0x0125, r24
	firstbyte.y = 0;
    127c:	10 92 27 01 	sts	0x0127, r1
    1280:	22 96       	adiw	r28, 0x02	; 2
    1282:	0f b6       	in	r0, 0x3f	; 63
    1284:	f8 94       	cli
    1286:	de bf       	out	0x3e, r29	; 62
    1288:	0f be       	out	0x3f, r0	; 63
    128a:	cd bf       	out	0x3d, r28	; 61
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	08 95       	ret

00001292 <pcc>:
}
/**************************************************************************/
/*!
*	\brief Hier werden die empfangenen Daten ausgewertet
*
***************************************************************************/
void pcc(uint8_t buf)
{
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	cd b7       	in	r28, 0x3d	; 61
    1298:	de b7       	in	r29, 0x3e	; 62
    129a:	21 97       	sbiw	r28, 0x01	; 1
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	f8 94       	cli
    12a0:	de bf       	out	0x3e, r29	; 62
    12a2:	0f be       	out	0x3f, r0	; 63
    12a4:	cd bf       	out	0x3d, r28	; 61
    12a6:	89 83       	std	Y+1, r24	; 0x01
	firstbyte.y = buf;
    12a8:	89 81       	ldd	r24, Y+1	; 0x01
    12aa:	80 93 27 01 	sts	0x0127, r24
    12ae:	21 96       	adiw	r28, 0x01	; 1
    12b0:	0f b6       	in	r0, 0x3f	; 63
    12b2:	f8 94       	cli
    12b4:	de bf       	out	0x3e, r29	; 62
    12b6:	0f be       	out	0x3f, r0	; 63
    12b8:	cd bf       	out	0x3d, r28	; 61
    12ba:	df 91       	pop	r29
    12bc:	cf 91       	pop	r28
    12be:	08 95       	ret

000012c0 <strcmp>:
    12c0:	fb 01       	movw	r30, r22
    12c2:	dc 01       	movw	r26, r24
    12c4:	8d 91       	ld	r24, X+
    12c6:	01 90       	ld	r0, Z+
    12c8:	80 19       	sub	r24, r0
    12ca:	11 f4       	brne	.+4      	; 0x12d0 <strcmp+0x10>
    12cc:	00 20       	and	r0, r0
    12ce:	d1 f7       	brne	.-12     	; 0x12c4 <strcmp+0x4>
    12d0:	99 0b       	sbc	r25, r25
    12d2:	08 95       	ret

000012d4 <itoa>:
    12d4:	fb 01       	movw	r30, r22
    12d6:	9f 01       	movw	r18, r30
    12d8:	e8 94       	clt
    12da:	42 30       	cpi	r20, 0x02	; 2
    12dc:	c4 f0       	brlt	.+48     	; 0x130e <itoa+0x3a>
    12de:	45 32       	cpi	r20, 0x25	; 37
    12e0:	b4 f4       	brge	.+44     	; 0x130e <itoa+0x3a>
    12e2:	4a 30       	cpi	r20, 0x0A	; 10
    12e4:	29 f4       	brne	.+10     	; 0x12f0 <itoa+0x1c>
    12e6:	97 fb       	bst	r25, 7
    12e8:	1e f4       	brtc	.+6      	; 0x12f0 <itoa+0x1c>
    12ea:	90 95       	com	r25
    12ec:	81 95       	neg	r24
    12ee:	9f 4f       	sbci	r25, 0xFF	; 255
    12f0:	64 2f       	mov	r22, r20
    12f2:	77 27       	eor	r23, r23
    12f4:	0e 94 f7 09 	call	0x13ee <__udivmodhi4>
    12f8:	80 5d       	subi	r24, 0xD0	; 208
    12fa:	8a 33       	cpi	r24, 0x3A	; 58
    12fc:	0c f0       	brlt	.+2      	; 0x1300 <itoa+0x2c>
    12fe:	89 5d       	subi	r24, 0xD9	; 217
    1300:	81 93       	st	Z+, r24
    1302:	cb 01       	movw	r24, r22
    1304:	00 97       	sbiw	r24, 0x00	; 0
    1306:	a1 f7       	brne	.-24     	; 0x12f0 <itoa+0x1c>
    1308:	16 f4       	brtc	.+4      	; 0x130e <itoa+0x3a>
    130a:	5d e2       	ldi	r21, 0x2D	; 45
    130c:	51 93       	st	Z+, r21
    130e:	10 82       	st	Z, r1
    1310:	c9 01       	movw	r24, r18
    1312:	0c 94 8b 09 	jmp	0x1316 <strrev>

00001316 <strrev>:
    1316:	dc 01       	movw	r26, r24
    1318:	fc 01       	movw	r30, r24
    131a:	01 90       	ld	r0, Z+
    131c:	00 20       	and	r0, r0
    131e:	e9 f7       	brne	.-6      	; 0x131a <strrev+0x4>
    1320:	32 97       	sbiw	r30, 0x02	; 2
    1322:	ae 17       	cp	r26, r30
    1324:	bf 07       	cpc	r27, r31
    1326:	30 f4       	brcc	.+12     	; 0x1334 <strrev+0x1e>
    1328:	7c 91       	ld	r23, X
    132a:	60 81       	ld	r22, Z
    132c:	70 83       	st	Z, r23
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	6d 93       	st	X+, r22
    1332:	f7 cf       	rjmp	.-18     	; 0x1322 <strrev+0xc>
    1334:	08 95       	ret

00001336 <__mulsi3>:
    1336:	62 9f       	mul	r22, r18
    1338:	d0 01       	movw	r26, r0
    133a:	73 9f       	mul	r23, r19
    133c:	f0 01       	movw	r30, r0
    133e:	82 9f       	mul	r24, r18
    1340:	e0 0d       	add	r30, r0
    1342:	f1 1d       	adc	r31, r1
    1344:	64 9f       	mul	r22, r20
    1346:	e0 0d       	add	r30, r0
    1348:	f1 1d       	adc	r31, r1
    134a:	92 9f       	mul	r25, r18
    134c:	f0 0d       	add	r31, r0
    134e:	83 9f       	mul	r24, r19
    1350:	f0 0d       	add	r31, r0
    1352:	74 9f       	mul	r23, r20
    1354:	f0 0d       	add	r31, r0
    1356:	65 9f       	mul	r22, r21
    1358:	f0 0d       	add	r31, r0
    135a:	99 27       	eor	r25, r25
    135c:	72 9f       	mul	r23, r18
    135e:	b0 0d       	add	r27, r0
    1360:	e1 1d       	adc	r30, r1
    1362:	f9 1f       	adc	r31, r25
    1364:	63 9f       	mul	r22, r19
    1366:	b0 0d       	add	r27, r0
    1368:	e1 1d       	adc	r30, r1
    136a:	f9 1f       	adc	r31, r25
    136c:	bd 01       	movw	r22, r26
    136e:	cf 01       	movw	r24, r30
    1370:	11 24       	eor	r1, r1
    1372:	08 95       	ret

00001374 <__udivmodsi4>:
    1374:	a1 e2       	ldi	r26, 0x21	; 33
    1376:	1a 2e       	mov	r1, r26
    1378:	aa 1b       	sub	r26, r26
    137a:	bb 1b       	sub	r27, r27
    137c:	fd 01       	movw	r30, r26
    137e:	0d c0       	rjmp	.+26     	; 0x139a <__udivmodsi4_ep>

00001380 <__udivmodsi4_loop>:
    1380:	aa 1f       	adc	r26, r26
    1382:	bb 1f       	adc	r27, r27
    1384:	ee 1f       	adc	r30, r30
    1386:	ff 1f       	adc	r31, r31
    1388:	a2 17       	cp	r26, r18
    138a:	b3 07       	cpc	r27, r19
    138c:	e4 07       	cpc	r30, r20
    138e:	f5 07       	cpc	r31, r21
    1390:	20 f0       	brcs	.+8      	; 0x139a <__udivmodsi4_ep>
    1392:	a2 1b       	sub	r26, r18
    1394:	b3 0b       	sbc	r27, r19
    1396:	e4 0b       	sbc	r30, r20
    1398:	f5 0b       	sbc	r31, r21

0000139a <__udivmodsi4_ep>:
    139a:	66 1f       	adc	r22, r22
    139c:	77 1f       	adc	r23, r23
    139e:	88 1f       	adc	r24, r24
    13a0:	99 1f       	adc	r25, r25
    13a2:	1a 94       	dec	r1
    13a4:	69 f7       	brne	.-38     	; 0x1380 <__udivmodsi4_loop>
    13a6:	60 95       	com	r22
    13a8:	70 95       	com	r23
    13aa:	80 95       	com	r24
    13ac:	90 95       	com	r25
    13ae:	9b 01       	movw	r18, r22
    13b0:	ac 01       	movw	r20, r24
    13b2:	bd 01       	movw	r22, r26
    13b4:	cf 01       	movw	r24, r30
    13b6:	08 95       	ret

000013b8 <__divmodsi4>:
    13b8:	97 fb       	bst	r25, 7
    13ba:	09 2e       	mov	r0, r25
    13bc:	05 26       	eor	r0, r21
    13be:	0e d0       	rcall	.+28     	; 0x13dc <__divmodsi4_neg1>
    13c0:	57 fd       	sbrc	r21, 7
    13c2:	04 d0       	rcall	.+8      	; 0x13cc <__divmodsi4_neg2>
    13c4:	d7 df       	rcall	.-82     	; 0x1374 <__udivmodsi4>
    13c6:	0a d0       	rcall	.+20     	; 0x13dc <__divmodsi4_neg1>
    13c8:	00 1c       	adc	r0, r0
    13ca:	38 f4       	brcc	.+14     	; 0x13da <__divmodsi4_exit>

000013cc <__divmodsi4_neg2>:
    13cc:	50 95       	com	r21
    13ce:	40 95       	com	r20
    13d0:	30 95       	com	r19
    13d2:	21 95       	neg	r18
    13d4:	3f 4f       	sbci	r19, 0xFF	; 255
    13d6:	4f 4f       	sbci	r20, 0xFF	; 255
    13d8:	5f 4f       	sbci	r21, 0xFF	; 255

000013da <__divmodsi4_exit>:
    13da:	08 95       	ret

000013dc <__divmodsi4_neg1>:
    13dc:	f6 f7       	brtc	.-4      	; 0x13da <__divmodsi4_exit>
    13de:	90 95       	com	r25
    13e0:	80 95       	com	r24
    13e2:	70 95       	com	r23
    13e4:	61 95       	neg	r22
    13e6:	7f 4f       	sbci	r23, 0xFF	; 255
    13e8:	8f 4f       	sbci	r24, 0xFF	; 255
    13ea:	9f 4f       	sbci	r25, 0xFF	; 255
    13ec:	08 95       	ret

000013ee <__udivmodhi4>:
    13ee:	aa 1b       	sub	r26, r26
    13f0:	bb 1b       	sub	r27, r27
    13f2:	51 e1       	ldi	r21, 0x11	; 17
    13f4:	07 c0       	rjmp	.+14     	; 0x1404 <__udivmodhi4_ep>

000013f6 <__udivmodhi4_loop>:
    13f6:	aa 1f       	adc	r26, r26
    13f8:	bb 1f       	adc	r27, r27
    13fa:	a6 17       	cp	r26, r22
    13fc:	b7 07       	cpc	r27, r23
    13fe:	10 f0       	brcs	.+4      	; 0x1404 <__udivmodhi4_ep>
    1400:	a6 1b       	sub	r26, r22
    1402:	b7 0b       	sbc	r27, r23

00001404 <__udivmodhi4_ep>:
    1404:	88 1f       	adc	r24, r24
    1406:	99 1f       	adc	r25, r25
    1408:	5a 95       	dec	r21
    140a:	a9 f7       	brne	.-22     	; 0x13f6 <__udivmodhi4_loop>
    140c:	80 95       	com	r24
    140e:	90 95       	com	r25
    1410:	bc 01       	movw	r22, r24
    1412:	cd 01       	movw	r24, r26
    1414:	08 95       	ret
